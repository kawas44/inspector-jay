cmdhistory=["(defmethod get-child \:default [node index]\\n  (let\\n    [meth (nth (.getMethods (.getClass (\:value node))) index)]\\n    {\:method meth})\\r\\n  )" "(defmulti get-child (fn [parent index] (node-kind parent)))" "\\r\\n(defmulti is-leaf node-kind)\\r\\n(defmulti get-child (fn [node index] (node-kind node)))\\r\\n(defmulti get-child-count node-kind)\\n\\n; Object nodes\\n(defmethod is-leaf \:object [node]\\r\\n  true)\\r\\n(defmethod get-child \:object [node index]\\n  (let\\n    [meth (nth (.getMethods (.getClass (\:value node))) index)]\\n    {\:method meth})\\r\\n  )\\r\\n(defmethod get-child-count \:default [parent]\\r\\n  (count parent))\\r\\n(defmethod get-child-count \:object [node]\\r\\n  (count (.getMethods (.getClass (node \:value)))))" "(instance? java.lang.reflect.Method (nth (.getMethods (.getClass (new java.lang.Object))) 0))" "(defn \\r\\n\\tinspect ^JFrame\\r\\n\\t[^Object object]\\r\\n\\t(let [f (frame \:title \\"Object inspector\\" \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (.toString(.getClass object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split obj-info (scrollable obj-tree) \:divider-location 1/3)]\\n   (.setCellRenderer obj-tree (tree-renderer))\\n   (config\! f \:content split-pane)\\r\\n\\t\\t(-> f pack\! show\!)\\r\\n\\t\\t(-> object .getClass .getSimpleName)))" "(defn tree-renderer []\\r\\n  (proxy [DefaultTreeCellRenderer] []))" "(defn \\r\\n\\tinspect ^JFrame\\r\\n\\t[^Object object]\\r\\n\\t(let [f (frame \:title \\"Object inspector\\" \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (.toString(.getClass object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split obj-info (scrollable obj-tree) \:divider-location 1/3)]\\n   (.setCellRenderer obj-tree (tree-renderer))\\n   (config\! f \:content split-pane)\\r\\n\\t\\t(-> f pack\! show\!)\\r\\n\\t\\t(-> object .getClass .getSimpleName)))" "(defn tree-renderer []\\r\\n  (proxy [DefaultTreeCellRenderer] []\\n    (getTreeCellRendererComponent [tree value selected expanded leaf row hasFocus]\\n      (proxy-super tree value selected expanded leaf row hasFocus))\\n    ))" "(defn \\r\\n\\tinspect ^JFrame\\r\\n\\t[^Object object]\\r\\n\\t(let [f (frame \:title \\"Object inspector\\" \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (.toString(.getClass object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split obj-info (scrollable obj-tree) \:divider-location 1/3)]\\n   (.setCellRenderer obj-tree (tree-renderer))\\n   (config\! f \:content split-pane)\\r\\n\\t\\t(-> f pack\! show\!)\\r\\n\\t\\t(-> object .getClass .getSimpleName)))" "(inspect (new java.lang.Object))" "(defn \\r\\n\\tinspect ^JFrame\\r\\n\\t[^Object object]\\r\\n\\t(let [f (frame \:title \\"Object inspector\\" \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (.toString(.getClass object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split obj-info (scrollable obj-tree) \:divider-location 1/3)]\\n   ;(.setCellRenderer obj-tree (tree-renderer))\\n   (config\! f \:content split-pane)\\r\\n\\t\\t(-> f pack\! show\!)\\r\\n\\t\\t(-> object .getClass .getSimpleName)))" "(inspect (new java.lang.Object))" "(defn tree-renderer []\\r\\n  (proxy [DefaultTreeCellRenderer] []\\n    (getTreeCellRendererComponent [tree value selected expanded leaf row hasFocus]\\n      (proxy-super tree value selected expanded leaf row hasFocus))\\n    ))" "(defn \\r\\n\\tinspect ^JFrame\\r\\n\\t[^Object object]\\r\\n\\t(let [f (frame \:title \\"Object inspector\\" \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (.toString(.getClass object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split obj-info (scrollable obj-tree) \:divider-location 1/3)]\\n   (.setCellRenderer obj-tree (tree-renderer))\\n   (config\! f \:content split-pane)\\r\\n\\t\\t(-> f pack\! show\!)\\r\\n\\t\\t(-> object .getClass .getSimpleName)))" "(inspect (new java.lang.Object))" "(defn tree-renderer []\\r\\n  (proxy [DefaultTreeCellRenderer] []\\n    (getTreeCellRendererComponent [tree value selected expanded leaf row hasFocus]\\n      (proxy-super getTreeCellRendererComponent tree value selected expanded leaf row hasFocus))\\n    ))" "(defn \\r\\n\\tinspect ^JFrame\\r\\n\\t[^Object object]\\r\\n\\t(let [f (frame \:title \\"Object inspector\\" \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (.toString(.getClass object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split obj-info (scrollable obj-tree) \:divider-location 1/3)]\\n   (.setCellRenderer obj-tree (tree-renderer))\\n   (config\! f \:content split-pane)\\r\\n\\t\\t(-> f pack\! show\!)\\r\\n\\t\\t(-> object .getClass .getSimpleName)))" "(comment\\n  (instance? java.lang.reflect.Method (nth (.getMethods (.getClass (new java.lang.Object))) 0))\\n  \\r\\n(defn collection-tag [x]\\r\\n  (cond\\r\\n   (instance? java.lang.reflect.Method x) \:method\\r\\n   \:else \:object))\\r\\n\\r\\n\\r\\n)" "(inspect (new java.lang.Object))" "(defn tree-renderer []\\r\\n  (proxy [DefaultTreeCellRenderer] []\\n    (getTreeCellRendererComponent [tree value selected expanded leaf row hasFocus]\\n      (proxy-super getTreeCellRendererComponent tree value selected expanded leaf row hasFocus)\\n      (.setText this (value \:value)))\\n    ))" "(inspect (new java.lang.Object))" "(defn \\r\\n\\tinspect ^JFrame\\r\\n\\t[^Object object]\\r\\n\\t(let [f (frame \:title \\"Object inspector\\" \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (.toString(.getClass object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split obj-info (scrollable obj-tree) \:divider-location 1/3)]\\n   (.setCellRenderer obj-tree (tree-renderer))\\n   (config\! f \:content split-pane)\\r\\n\\t\\t(-> f pack\! show\!)\\r\\n\\t\\t(-> object .getClass .getSimpleName)))" "(inspect (new java.lang.Object))" "(defn tree-renderer []\\r\\n  (proxy [DefaultTreeCellRenderer] []\\n    (getTreeCellRendererComponent [tree value selected expanded leaf row hasFocus]\\n      (let []\\n      (proxy-super getTreeCellRendererComponent tree value selected expanded leaf row hasFocus)\\n      (.setText this (value \:value)))\\n      )\\n    ))" "(inspect (new java.lang.Object))" "(defn tree-renderer []\\r\\n  (proxy [DefaultTreeCellRenderer] []\\n    (getTreeCellRendererComponent [tree value selected expanded leaf row hasFocus]\\n      (proxy-super getTreeCellRendererComponent tree value selected expanded leaf row hasFocus)\\n      (.setText this \\"Hello\\"))\\n    ))" "(defn tree-renderer []\\r\\n  (proxy [DefaultTreeCellRenderer] []\\n    (getTreeCellRendererComponent [tree value selected expanded leaf row hasFocus]\\n      (proxy-super getTreeCellRendererComponent tree value selected expanded leaf row hasFocus)\\n      (.setText this \\"Hello\\")\\n      this)\\n    ))" "(defn tree-renderer []\\r\\n  (proxy [DefaultTreeCellRenderer] []\\n    (getTreeCellRendererComponent [tree value selected expanded leaf row hasFocus]\\n      (proxy-super getTreeCellRendererComponent tree value selected expanded leaf row hasFocus)\\n      (.setText this (.toString(value \:value)))\\n      this)\\n    ))" "(defmulti to-string node-kind)" "(join [\\"hello\\" \\"world\\"])" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use [clojure.string])\\r\\n  (\:use [seesaw.core])\\n  (\:use [seesaw.font])\\n  (\:import\\r\\n     (java.awt BorderLayout)\\r\\n     (java.awt.event ActionEvent ActionListener)\\r\\n     (javax.swing.tree TreeModel DefaultTreeCellRenderer)\\r\\n     (javax.swing.table TableModel AbstractTableModel)\\r\\n     (javax.swing JPanel JTree JTable JScrollPane JFrame JToolBar JButton SwingUtilities)))" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\r\\n  (\:use [seesaw.core])\\n  (\:use [seesaw.font])\\n  (\:import\\r\\n     (java.awt BorderLayout)\\r\\n     (java.awt.event ActionEvent ActionListener)\\r\\n     (javax.swing.tree TreeModel DefaultTreeCellRenderer)\\r\\n     (javax.swing.table TableModel AbstractTableModel)\\r\\n     (javax.swing JPanel JTree JTable JScrollPane JFrame JToolBar JButton SwingUtilities)))" ";; Switching to inspector-jay.core namespace" "(join [\\"a\\" \\"b\\"])" "(clojure.string/join [\\"a\\" \\"b\\"])" ";; Switching to inspector-jay.core namespace" "(join [\\"a\\" \\"b\\"])" "(join)" "(use '[clojure.string \:only (join split)])" "(join)" ";; Switching to inspector-jay.core namespace" "(join [\\"a\\"])" "(clojure.core/ns inspector-jay.core)\\n(join [\\"a\\" \\"b\\"])\\n(clojure.core/ns user)" "(join [\\"a\\"])" "(join [\\"a\\" \\"b\\"])" ";; Switching to inspector-jay.core namespace" "(join [\\"a\\" \\"b\\"])" "(defmethod to-string \:method [node]\\r\\n  (join [ \\"<html><font color\='blue'>\\"\\n         (.getName (node \:method))\\n         \\"</font>(\\"\\n         (.getParameterTypes (node \:method))\\n         \\")</html>\\"])\\n  (interpose \\", \\" (map .getName (.getParameterTypes (node \:method)))))" "(defmethod to-string \:method [node]\\r\\n  (join [ \\"<html><font color\='blue'>\\"\\n         (.getName (node \:method))\\n         \\"</font>(\\"\\n         (.getParameterTypes (node \:method))\\n         \\")</html>\\"])\\n  (interpose \\", \\" (map \#(.getName) (.getParameterTypes (node \:method)))))" "(defmethod to-string \:method [node]\\r\\n  (join [ \\"<html><font color\='blue'>\\"\\n         (.getName (node \:method))\\n         \\"</font>(\\"\\n         (.getParameterTypes (node \:method))\\n         \\")</html>\\"])\\n  (interpose \\", \\" (map (memfn getName) (.getParameterTypes (node \:method)))))" "(defmethod to-string \:method [node]\\r\\n  (join [ \\"<html><font color\='blue'>\\"\\n         (.getName (node \:method))\\n         \\"</font>(\\"\\n         (.getParameterTypes (node \:method))\\n         \\")</html>\\"])\\n  (.toString (interpose \\", \\" (map (memfn getName) (.getParameterTypes (node \:method))))))" "(defn \\r\\n\\tinspect ^JFrame\\r\\n\\t[^Object object]\\r\\n\\t(let [f (frame \:title \\"Object inspector\\" \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (.toString(.getClass object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split obj-info (scrollable obj-tree) \:divider-location 1/3)]\\n   (.setCellRenderer obj-tree (tree-renderer))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (config\! f \:content split-pane)\\r\\n\\t\\t(-> f pack\! show\!)))" "(defn tree-listener \\n  [info-panel]\\n  (proxy [TreeSelectionListener]\\n    (valueChanged [event]\\n      (println event))))" "(defn tree-renderer []\\r\\n  (proxy [DefaultTreeCellRenderer] []\\n    (getTreeCellRendererComponent [tree value selected expanded leaf row hasFocus]\\n      (proxy-super getTreeCellRendererComponent tree value selected expanded leaf row hasFocus)\\n      (.setText this (to-string value ))\\n      this)))" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use [clojure.string \:only [split join]])\\r\\n  (\:use [seesaw.core])\\n  (\:use [seesaw.font])\\n  (\:import\\r\\n     (java.awt BorderLayout)\\r\\n     (java.awt.event ActionEvent ActionListener)\\r\\n     (javax.swing.tree TreeModel DefaultTreeCellRenderer)\\r\\n     (javax.swing.table TableModel AbstractTableModel)\\r\\n     (javax.swing JPanel JTree JTable JScrollPane JFrame JToolBar JButton SwingUtilities)\\n     (javax.swing.event TreeSelectionListener)))" "(defn tree-listener \\n  [info-panel]\\n  (proxy [TreeSelectionListener] []\\n    (valueChanged [event]\\n      (println event))))" "(doc if)" "(defn num-of-fields\\r\\n  [object]\\r\\n  (count (-> object .getClass getFields)))" "(defmethod get-child \:object [node index]\\n  (if (< index (count (-> (node \:value) .getClass .getMethods)))\\n    (let\\n      [meth (nth (.getMethods (.getClass (\:value node))) index)]\\n      {\:method meth})\\n    (let\\n      [field-index (- index (count (-> (node \:value) .getClass .getMethods)))]\\n      [field ]\\r\\n  )\\r\\n(defmethod get-child-count \:default [parent]\\r\\n  (count parent))\\r\\n(defmethod get-child-count \:object [node]\\n  (+ \\n    (count (-> (node \:value) .getClass .getMethods))\\n    (count (-> (node \:value) .getClass .getFields))))" "(defmethod get-child \:object [node index]\\n  (if (< index (count (-> (node \:value) .getClass .getMethods)))\\n    (let\\n      [meth (nth (.getMethods (.getClass (\:value node))) index)]\\n      {\:method meth})\\n    (let\\n      [field-index (- index (count (-> (node \:value) .getClass .getMethods)))]\\n      [field ]\\r\\n  )\\r\\n(defmethod get-child-count \:default [parent]\\r\\n  (count parent))\\n\\r\\n(defmethod get-child-count \:object [node]\\n  (+ \\n    (count (-> (node \:value) .getClass .getMethods))\\n    (count (-> (node \:value) .getClass .getFields))))" "(defmethod get-child \:object [node index]\\n  (if (< index (count (-> (node \:value) .getClass .getMethods)))\\n    (let\\n      [meth (nth (.getMethods (.getClass (\:value node))) index)]\\n      {\:method meth})\\n    (let\\n      [field-index (- index (count (-> (node \:value) .getClass .getMethods)))]\\n      [field ]\\r\\n  )\\n    \\r\\n(defmethod get-child-count \:default [parent]\\r\\n  (count parent))" "{\:a 3 \:b 4}" "(def bla {\:a 3 \:b 4})" "(bla \:a)" "(\:a bla)" "(defmethod get-child \:object [node index]\\n  (if (< index (count (-> (node \:value) .getClass .getMethods)))\\n    (let\\n      [meth (nth (.getMethods (.getClass (node \:value))) index)]\\n      {\:method meth})\\n    (let\\n      [field-index (- index (num-of-methods (node \:value)))]\\n      [field (nth (-> (node\:value) .getClass .getFields))]\\n      {\:field field})))" "(defn num-of-methods\\n  \\"Retrieve the number of methods in an object\\"\\n  [object]\\n  (count (-> object .getClass .getMethods)))" "(defn num-of-fields\\r\\n  [object]\\r\\n  (count (-> object .getClass getFields)))" "(defn num-of-fields\\r\\n  [object]\\r\\n  (count (-> object .getClass .getFields)))" "(inspect (new Test))" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use [clojure.string \:only [split join]])\\r\\n  (\:use [seesaw.core])\\n  (\:use [seesaw.font])\\n  (\:import\\n     (inspector-jay Test)\\r\\n     (java.awt BorderLayout)\\r\\n     (java.awt.event ActionEvent ActionListener)\\r\\n     (javax.swing.tree TreeModel DefaultTreeCellRenderer)\\r\\n     (javax.swing.table TableModel AbstractTableModel)\\r\\n     (javax.swing JPanel JTree JTable JScrollPane JFrame JToolBar JButton SwingUtilities)\\n     (javax.swing.event TreeSelectionListener)))" "(import '(inspector-jay.Test))" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use [clojure.string \:only [split join]])\\r\\n  (\:use [seesaw.core])\\n  (\:use [seesaw.font])\\n  (\:import\\n     (inspector_jay Test)\\r\\n     (java.awt BorderLayout)\\r\\n     (java.awt.event ActionEvent ActionListener)\\r\\n     (javax.swing.tree TreeModel DefaultTreeCellRenderer)\\r\\n     (javax.swing.table TableModel AbstractTableModel)\\r\\n     (javax.swing JPanel JTree JTable JScrollPane JFrame JToolBar JButton SwingUtilities)\\n     (javax.swing.event TreeSelectionListener)))" "(inspect (new Test))" "(num-of-fields (new Test))" ";; Switching to inspector-jay.core namespace" "(clojure.core/ns inspector-jay.core)\\n(num-of-fields (new Test))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.core)\\n(num-of-methods (new Test))\\n(clojure.core/ns user)" ";; Switching to inspector-jay.core namespace" "(.bar (new Test))" "(.foo (new Test))" "(.bar (new Test))" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use [clojure.string \:only [split join]])\\r\\n  (\:use [seesaw.core])\\n  (\:use [seesaw.font])\\n  (\:import\\n     (scratchpad Test)\\r\\n     (java.awt BorderLayout)\\r\\n     (java.awt.event ActionEvent ActionListener)\\r\\n     (javax.swing.tree TreeModel DefaultTreeCellRenderer)\\r\\n     (javax.swing.table TableModel AbstractTableModel)\\r\\n     (javax.swing JPanel JTree JTable JScrollPane JFrame JToolBar JButton SwingUtilities)\\n     (javax.swing.event TreeSelectionListener)))" ";; Switching to inspector-jay.core namespace" "(num-of-methods (new Test))" "(.bar (new Test))" "(.baz (new Test))" ";; Switching to inspector-jay.core namespace" "(.bar (new Test))" "(num-of-methods (new Test))" "(inspect (new Test))" "(num-of-fields (new Test))" "(.getDeclaredFields (.getClass (new Test)))" "(count (.getDeclaredFields (.getClass (new Test)))" "(count (.getDeclaredFields (.getClass (new Test))))" "(count (.getFields (.getClass (new Test))))" ";; Switching to inspector-jay.core namespace" "(count (.getFields (.getClass (new Test))))" "(count (.getDeclaredFields (.getClass (new Test))))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(.getFile (clojure.java.io/resource \\"file_obj.gif\\"))" "(icon (clojure.java.io/resource \\"file_obj.gif\\"))" "(defmulti get-icon node-kind)" "(defmulti- get-icon node-kind)" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use [clojure.string \:only [split join]])\\n  (\:use [clojure.java.io \:only [resource]])\\r\\n  (\:use [seesaw.core])\\n  (\:use [seesaw.font])\\n  (\:import\\n     (scratchpad Test)\\r\\n     (java.awt BorderLayout)\\r\\n     (java.awt.event ActionEvent ActionListener)\\r\\n     (javax.swing.tree TreeModel DefaultTreeCellRenderer)\\r\\n     (javax.swing.table TableModel AbstractTableModel)\\r\\n     (javax.swing JPanel JTree JTable JScrollPane JFrame JToolBar JButton SwingUtilities ImageIcon)\\n     (javax.swing.event TreeSelectionListener)\\n     (java.lang.reflect Modifier)))" "(.FINAL Modifier)" "(Modifier/FINAL)" "(defmethod get-icon \:field [node]\\n  (let\\n    [mod (-> (node \:field ) .getModifiers)]\\n  (cond\\n    (Modifier/isPublic mod) (icon (resource \\"field_public_obj.gif\\"))\\n    (Modifier/isPrivate mod) (icon (resource \\"field_private_obj.gif\\"))\\n    (Modifier/isPrivate mod) (icon (resource \\"field_protected_obj.gif\\"))\\n    \:else (icon (resource \\"field_default_obj.gif\\")))))" "(defmulti to-string-verbose node-kind)" "(defmulti \#{\:private true} to-string-verbose node-kind)" "(defmulti- to-string-verbose node-kind)" "(clojure.core/ns inspector-jay.tree-model)\\n(ns inspector-jay.tree-model\\n  (\:use [inspector-jay.common]))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmulti is-leaf node-kind)\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.common)\\n(defn node-kind \\r\\n  [node]\\r\\n  \\"Determine what kind of tree node we're dealing with\\r\\n@param node the tree node (a map with these keys \:value [\:parent \:method|\:field] )\\"\\r\\n  (cond\\r\\n    (sequential? (node \:value)) \:sequence\\r\\n    (contains? node \:method) \:method\\r\\n    (contains? node \:field) \:field\\r\\n    \:else \:object))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmulti is-leaf node-kind)\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmulti is-leaf \\"Hello\\" node-kind)\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmulti to-string\\n  \\"Retrieve a short description of a tree node\\"\\n  node-kind)\\n(clojure.core/ns inspector-jay.core)" ";; Switching to inspector-jay.core namespace" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use [clojure.string \:only [split join]])\\n  (\:use [clojure.java.io \:only [resource]])\\r\\n  (\:use [seesaw.core])\\n  (\:use [seesaw.font])\\n  (\:use [inspector-jay.common])\\n  (\:import\\n     (scratchpad Test)\\r\\n     (java.awt BorderLayout)\\r\\n     (java.awt.event ActionEvent ActionListener)\\r\\n     (javax.swing.tree TreeModel DefaultTreeCellRenderer)\\r\\n     (javax.swing JPanel JTree JTable JScrollPane JFrame JToolBar JButton SwingUtilities)\\n     (javax.swing.event TreeSelectionListener)\\n     (java.lang.reflect Modifier)))" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use [clojure.string \:only [split join]])\\n  (\:use [clojure.java.io \:only [resource]])\\r\\n  (\:use [seesaw.core])\\n  (\:use [seesaw.font])\\n  (\:use\\n    [inspector-jay\\n     [tree-model]\\n     [tree-ui]])\\n  (\:import\\n     (scratchpad Test)\\r\\n     (java.awt BorderLayout)\\r\\n     (java.awt.event ActionEvent ActionListener)\\r\\n     (javax.swing.tree TreeModel DefaultTreeCellRenderer)\\r\\n     (javax.swing JPanel JTree JTable JScrollPane JFrame JToolBar JButton SwingUtilities)\\n     (javax.swing.event TreeSelectionListener)\\n     (java.lang.reflect Modifier)))" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use [clojure.java.io \:only [resource]])\\r\\n  (\:use [seesaw.core])\\n  (\:use [seesaw.font])\\n  (\:use\\n    [clojure.string \:only [split join]]\\n    [inspector-jay\\n     [tree-model]\\n     [tree-ui]])\\n  (\:import\\n     (scratchpad Test)\\r\\n     (java.awt BorderLayout)\\r\\n     (java.awt.event ActionEvent ActionListener)\\r\\n     (javax.swing.tree TreeModel DefaultTreeCellRenderer)\\r\\n     (javax.swing JPanel JTree JTable JScrollPane JFrame JToolBar JButton SwingUtilities)\\n     (javax.swing.event TreeSelectionListener)\\n     (java.lang.reflect Modifier)))" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use\\n    [clojure\\n     [string \:only [split join]]]\\n    [seesaw\\n     [core]\\n     [font]]\\n    [inspector-jay\\n     [tree-model]\\n     [tree-ui]])\\n  (\:import\\n    [.scratchpad.Test]\\r\\n     (java.awt BorderLayout)\\r\\n     (java.awt.event ActionEvent ActionListener)\\r\\n     (javax.swing.tree TreeModel DefaultTreeCellRenderer)\\r\\n     (javax.swing JPanel JTree JTable JScrollPane JFrame JToolBar JButton SwingUtilities)\\n     (javax.swing.event TreeSelectionListener)\\n     (java.lang.reflect Modifier)))" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use\\n    [clojure\\n     [string \:only [split join]]]\\n    [seesaw\\n     [core]\\n     [font]]\\n    [inspector-jay\\n     [tree-model]\\n     [tree-ui]])\\n  (\:import\\n    [scratchpad Test]\\n    [java.awt BorderLayout]\\r\\n     \\r\\n     (java.awt.event ActionEvent ActionListener)\\r\\n     (javax.swing.tree TreeModel DefaultTreeCellRenderer)\\r\\n     (javax.swing JPanel JTree JTable JScrollPane JFrame JToolBar JButton SwingUtilities)\\n     (javax.swing.event TreeSelectionListener)\\n     (java.lang.reflect Modifier)))" ";; Switching to inspector-jay.core namespace" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use\\n    [clojure\\n     [string \:only [split join]]]\\n    [seesaw\\n     [core]\\n     [font]]\\n    [inspector-jay\\n     [tree-model]\\n     [tree-ui]])\\n  (\:import\\n    [scratchpad Test]\\n    [java.awt BorderLayout]\\r\\n    [java.awt.event ActionEvent ActionListener]\\r\\n     [javax.swing.tree TreeModel DefaultTreeCellRenderer]\\r\\n     (javax.swing JPanel JTree JTable JScrollPane JFrame JToolBar JButton SwingUtilities)\\n     (javax.swing.event TreeSelectionListener)\\n     (java.lang.reflect Modifier)))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-renderer ^DefaultTreeCellRenderer\\n  []\\r\\n  \\"Returns a cell renderer which defines what each tree node should look like\\"\\r\\n  (proxy [DefaultTreeCellRenderer] []\\r\\n    (getTreeCellRendererComponent [tree value selected expanded leaf row hasFocus]\\r\\n      (proxy-super getTreeCellRendererComponent tree value selected expanded leaf row hasFocus)\\r\\n      (-> this (.setText (to-string value)))\\r\\n      (-> this (.setIcon (get-icon value)))\\r\\n      this)))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  \\"Returns a listener that displays detailed information when a tree node is clicked\\"\\r\\n  [^JTextArea info-panel]\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\r\\n      (config\! info-panel \:text (.toString event)))))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel]  \\n  \\"Returns a listener that displays detailed information when a tree node is clicked\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\r\\n      (config\! info-panel \:text (.toString event)))))\\n(clojure.core/ns inspector-jay.core)" ";; Switching to inspector-jay.core namespace" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string-verbose \:object [node]\\n  (join [\\n         (-> (node \:value) .getClass .getName)\\n         \\"/n\\"\\n         (-> (node \:value) .toString)\\n         ]))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.core)\\n(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\nNote that the object itself is also returned such that you can use this function anywhere without affecting the program's behaviour.\\"\\r\\n\\t(let [f (frame \:title (join [\\"Object inspector \: \\" (to-string-verbose {\:value object})]) \\n                \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (.toString(.getClass object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (config\! f \:content split-pane)\\n   (-> f pack\! show\!)\\n   object))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.core)\\n(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\nNote that the object itself is also returned such that you can use this function anywhere without affecting the program's behaviour.\\"\\r\\n\\t(let [f (frame \:title (join [\\"Object inspector \: \\" (.toString object)]) \\n                \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (.toString(.getClass object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (config\! f \:content split-pane)\\n   (-> f pack\! show\!)\\n   object))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string-verbose \:field [node]\\n  (join [\\n         (-> (node \:field) .toString)\\n         \\"\\\\n\\\\n\\"\\n         (node \:value)\\n         ]))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod get-child-count \:default [node]\\r\\n  (+ \\r\\n    (num-of-methods (node \:value))\\r\\n    (num-of-fields (node \:value))))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(ns inspector-jay.tree-model\\n  \\"Defines the tree structure of the object inspector\\"\\r\\n  {\:author \\"Tim Molderez\\"}\\n  (\:use \\n    [inspector-jay.common])\\n  (\:import\\r\\n     [javax.swing.tree TreeModel]\\n     [java.lang.reflect Method]))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod get-child \:default [node index]\\r\\n  (if (< index (num-of-methods (node \:value)))\\r\\n    (let\\r\\n      [meth (nth (.getMethods (.getClass (node \:value))) index)]\\r\\n      (transient {\:method meth \:parent node}))\\r\\n    (let\\r\\n      [field-index (- index (num-of-methods (node \:value)))\\r\\n       field (nth (-> (node \:value) .getClass .getDeclaredFields) field-index)]\\r\\n      (-> field (.setAccessible true)) ; Enable access to private fields\\r\\n      {\:field field \:parent node \:value (-> field (.get (node \:value)))})))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  (setValue [this val]\\n    (set\! value val))\\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  (setValue [this val]\\n    (set\! value val))\\n)\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n\\n)\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  (setValue [this val]\\n    (set\! value val))\\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  (setValue [this val]\\n    5)\\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  \\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  Object\\n  (setValue [this val]\\n    (set\! value val))\\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(defprotocol IPlaceholder\\n  (setValue [this val])\\n  (toString [this]))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  (setValue [this val]\\n    (set\! value val))\\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(defprotocol IPlaceholder\\n  (setValue [this val])\\n  (toString [this]))\\n\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  (setValue [this val]\\n    (set\! value val))\\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  \\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(defprotocol IPlaceholder\\n  (setValue [val])\\n  (toString []))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(defprotocol IPlaceholder\\n  (setValue [this val])\\n  (toString [this]))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  (toString [this] \\n    \\"hello\\")\\n  (setValue [this val]\\r\\n    (set\! value val)))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  (setValue [this val]\\n    (set\! value val))\\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  (setValue [this val]\\n    5)\\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(definterface IPlaceholder\\n  (setValue [this val])\\n  (toString [this]))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\nprotocol\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(defprotocol IPlaceholder\\n  (setValue [this val])\\n  (toString [this]))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(definterface IPlaceholder\\n  (setValue [this val])\\n  (toString [this]))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  (setValue [this val]\\n    (set\! value val))\\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(defprotocol IPlaceholder\\n  (setValue [this val])\\n  (toString [this]))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  (setValue [this val]\\n    (set\! value val))\\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [value]\\n  IPlaceholder\\n  (setValue [this val]\\n    (set\! value val))\\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  (setValue [this val]\\n    (set\! value val))\\n  (toString [this] \\n    5))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  (setValue [this val]\\n    (set\! value val))\\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(defrecord Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  (setValue [this val]\\n    (set\! value val))\\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  (setValue [this val]\\n    (set\! value val))\\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  \\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  (setValue [val] 5)\\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  (setValue [this val] 5)\\n  (toString [this] \\n    \\"hello\\"))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(definterface IPoint\\r\\n  (getX [])\\r\\n  (setX [v]))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Point [x]\\r\\n  IPoint\\r\\n  (getX [this] x)\\r\\n  (setX [this v] (set\! (.x this) v)))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(deftype Point [^{\:volatile-mutable true} x]\\r\\n  IPoint\\r\\n  (getX [_] x)\\r\\n  (setX [this v] (set\! x v)))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(definterface IPlaceholder\\n  (setValue [val])\\n  (toString []))\\n(clojure.core/ns user)" "(clojure.core/ns inspector-jay.tree-model)\\n(definterface IPlfsdaceholder\\n  (setValue [val])\\n  (toString []))\\n(clojure.core/ns user)" ";; Switching to inspector-jay.tree-model namespace" "(definterface IPlaceholder\\n  (setValue [val])\\n  (toString []))" "(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  (setValue [this val] 5)\\n  (toString [this] \\n    \\"hello\\"))" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns inspector-jay.tree-model)" "(defmethod get-child-count \:default [node]\\r\\n  (+ (num-of-methods (node \:value)) (num-of-fields (node \:value))))" "(defmethod get-child-count \:method [node]\\r\\n  (+ (num-of-methods (node \:value)) (num-of-fields (node \:value))))" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns inspector-jay.tree-model)" "(new Placeholder)" "(Placeholder.)" "(definterface IPlaceholder\\n  (setValue [val])\\n  (toString []))" "(deftypePlaceholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  (setValue [this val] 5)\\n  (toString [this] \\n    \\"hello\\"))" "(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  (setValue [this val] 5)\\n  (toString [this] \\n    \\"hello\\"))" ";; Switching to inspector-jay.tree-model namespace" "(new Placeholder)" "(new Placeholder nil)" "(def bla (new Placeholder nil))" "(.setValue bla (Object new))" "(.setValue bla (new Object))" "(def bla (new Placeholder nil))" "(num-of-methods bla)" "(num-of-fields bla)" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns inspector-jay.tree-model)" "(defmethod get-child \:default [node index]\\r\\n  (if (< index (num-of-methods (node \:value)))\\r\\n    (let\\r\\n      [meth (nth (.getMethods (.getClass (node \:value))) index)]\\r\\n      {\:method meth \:value (new Object) \:parent node})\\r\\n    (let\\r\\n      [field-index (- index (num-of-methods (node \:value)))\\r\\n       field (nth (-> (node \:value) .getClass .getDeclaredFields) field-index)]\\r\\n      (-> field (.setAccessible true)) ; Enable access to private fields\\r\\n      {\:field field \:value (-> field (.get (node \:value))) \:parent node})))" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns inspector-jay.tree-model)" "(defmethod get-child \:default [node index]\\r\\n  (if (< index (num-of-methods (node \:value)))\\r\\n    (let\\r\\n      [meth (nth (.getMethods (.getClass (node \:value))) index)]\\r\\n      {\:method meth \:value (new PlaceHolder nil) \:parent node})\\r\\n    (let\\r\\n      [field-index (- index (num-of-methods (node \:value)))\\r\\n       field (nth (-> (node \:value) .getClass .getDeclaredFields) field-index)]\\r\\n      (-> field (.setAccessible true)) ; Enable access to private fields\\r\\n      {\:field field \:value (-> field (.get (node \:value))) \:parent node})))" "(deftype Placeholder\\n  [^{\:volatile-mutable true} value]\\n  IPlaceholder\\n  (setValue [this val] (set\! value val))\\n  (toString [this] \\n    \\"hello\\"))" "(definterface IPlaceholder\\n  (setValue [val])\\n  (toString []))" "(defmethod get-child \:default [node index]\\r\\n  (if (< index (num-of-methods (node \:value)))\\r\\n    (let\\r\\n      [meth (nth (.getMethods (.getClass (node \:value))) index)]\\r\\n      {\:method meth \:value (new PlaceHolder nil) \:parent node})\\r\\n    (let\\r\\n      [field-index (- index (num-of-methods (node \:value)))\\r\\n       field (nth (-> (node \:value) .getClass .getDeclaredFields) field-index)]\\r\\n      (-> field (.setAccessible true)) ; Enable access to private fields\\r\\n      {\:field field \:value (-> field (.get (node \:value))) \:parent node})))" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns inspector-jay.tree-model)" "(definterface IPlaceholder\\n  \\"Mutable container for an object\\"\\r\\n  (setValue \\n    [val]\\n    \\"Set the object that the placeholder should contain (may be nil)\\")\\r\\n  (^String toString []))" "(definterface IPlaceholder\\n  \\"Mutable container for an object\\"\\r\\n  (setValue \\n    [val]\\n    \\"Set the object that the placeholder should contain (may be nil)\\")\\r\\n  (toString []))" "(definterface IPlaceholder\\n  \\"Mutable container for an object\\"\\r\\n  (setValue \\n    [val])\\r\\n  (toString []))" "(definterface IPlaceholder\\r\\n  (setValue \\n    [val])\\r\\n  (toString []))" "(definterface IPlaceholder\\n  \\"fdjfs\\"\\r\\n  (setValue \\n    [val])\\r\\n  (toString []))" "(definterface \\"fdsfs\\" IPlaceholder\\r\\n  (setValue \\n    [val])\\r\\n  (toString []))" "(definterface IPlaceholder\\r\\n  (setValue \\n    [val])\\r\\n  (toString []))" "(deftype Placeholder\\n  \\"gell\\"\\r\\n  [^{\:volatile-mutable true} value]\\r\\n  IPlaceholder\\r\\n  (setValue [this val] (set\! value val))\\r\\n  (toString [this] \\r\\n    \\"hello\\"))" "(deftype Placeholder\\r\\n  [^{\:volatile-mutable true} value]\\r\\n  IPlaceholder\\n  \\"sdas\\"\\r\\n  (setValue [this val] (set\! value val))\\r\\n  (toString [this] \\r\\n    \\"hello\\"))" "(deftype Placeholder\\r\\n  [^{\:volatile-mutable true} value]\\n  \\"dsfsd\\"\\r\\n  IPlaceholder\\r\\n  (setValue [this val] (set\! value val))\\r\\n  (toString [this] \\r\\n    \\"hello\\"))" "(defmulti is-leaf\\n  \\"Is this tree node a leaf?\\"\\n  node-kind)" "(definterface IPlaceholder\\r\\n  (setValue [val])\\r\\n  (toString ^String []))" "(deftype Placeholder\\r\\n  [^{\:volatile-mutable true} value]\\r\\n  IPlaceholder\\r\\n  (setValue [this val] (set\! value val))\\r\\n  (toString [this] \\r\\n    (-> val .toString)))" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns inspector-jay.tree-model)" "(deftype Placeholder\\r\\n  [^{\:volatile-mutable true} value]\\r\\n  IPlaceholder\\r\\n  (setValue [this val] (set\! value val))\\r\\n  (toString ^String [this] \\r\\n    (-> val .toString)))" "(definterface IPlaceholder\\r\\n  (setValue [val])\\r\\n  (toString ^String []))" "(deftype Placeholder\\r\\n  [^{\:volatile-mutable true} value]\\r\\n  IPlaceholder\\r\\n  (setValue [this val] (set\! value val))\\r\\n  (toString ^String [this] \\r\\n    (-> val .toString)))" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns inspector-jay.tree-model)" "(definterface IPlaceholder\\r\\n  (setValue [val])\\r\\n  (hasValue ^Boolean []))" "(deftype Placeholder\\r\\n  [^{\:volatile-mutable true} value]\\r\\n  IPlaceholder\\r\\n  (setValue [this val] (set\! value val))\\r\\n  (hasValue [this] (not\= val nil)))" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns inspector-jay.tree-model)" "(definterface IPlaceholder\\r\\n  (setValue [val])\\r\\n  (hasValue ^Boolean []))\\r\\n\\r\\n(deftype Placeholder\\r\\n  [^{\:volatile-mutable true} value]\\r\\n  IPlaceholder\\r\\n  (setValue [this val] (set\! value val))\\r\\n  (hasValue [this] (not\= val nil)))\\n" "(defmethod get-child-count \:method [node]\\n  (if-not (-> (node \:value) .hasValue)\\n    (-> (node \:value (.setValue (method-invoke (node \:method) ((node \:parent) \:value))))))\\r\\n  (+ (num-of-methods (node \:value)) (num-of-fields (node \:value))))" "(defmethod get-child-count \:method [node]\\n  (if-not (-> (node \:value) .hasValue)\\n    (-> (node \:value (.setValue (invoke-method (node \:method) ((node \:parent) \:value))))))\\r\\n  (+ (num-of-methods (node \:value)) (num-of-fields (node \:value))))" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns inspector-jay.tree-model)" ";; Switching to inspector-jay.core namespace" "(def my-delay (delay (println \\"did some work\\") 100))" "(my-delay)" "my-delay" "@my-delay" "my-delay" "(type my-delay)" "(def my-delay2 (delay (new Object)))" "my-delay2" "@my-delay2" "(.getClass my-delay)" "(num-of-methods my-delay)" ";; Switching to inspector-jay.tree-model namespace" "(num-of-methods my-delay)" "(num-of-methods my-delay2)" "(def my-delay2 (delay (new Object)))" "(num-of-methods my-delay2)" "my-delay2" "@my-delay2" "(type @my-delay2)" "(def bla (new Object))" "(type @bla)" "(force (new Object))" "(def my-delay2 (delay (new Object)))" "my-delay2" "(force my-delay2)" "(def my-delay2 (delay 5))" "(+ my-delay2)" "(deftype Placeholder\\r\\n  [^{\:volatile-mutable true} value]\\r\\n  IPlaceholder\\r\\n  (setValue [this val] (set\! value val))\\r\\n  (hasValue ^Boolean [this] (not\= val nil)))" "(definterface TreeNode\\r\\n  (getDescription ^String [])\\n  (getVerboseDescription ^String [])\\r\\n  (getIcon ^Icon []))" "(clojure.core/ns inspector-jay.common)\\n(defn node-class ^Class\\n  [node]\\n  \\"Retrieve the type of the node's value\\"\\n  (-> (force (node \:value)) .getClass)\\n)\\n(clojure.core/ns inspector-jay.tree-model)" "(defmethod get-child \:default [node index]\\r\\n  (if (< index (num-of-methods (node \:value)))\\r\\n    (let\\r\\n      [meth (nth (.getMethods (node-class node)) index)]\\r\\n      {\:method meth \:value (delay (invoke-method (node \:method) ((node \:parent) \:value))) \:parent node})\\r\\n    (let\\r\\n      [field-index (- index (num-of-methods (node \:value)))\\r\\n       field (nth (-> (node-class node) .getDeclaredFields) field-index)]\\r\\n      (-> field (.setAccessible true)) ; Enable access to private fields\\r\\n      {\:field field \:value (-> field (.get (node \:value))) \:parent node})))" ";; Switching to inspector-jay.tree-node namespace" "(definterface ITreeNode\\n  (getValue [])\\n  (getMethod [])\\n  (getField []))" "(deftype TreeNode\\r\\n  [data]\\r\\n  ITreeNode\\n  (getValue [this] (force (data \:value)))\\n  (getMethod [this] (data \:method))\\n  (getField [this] (data \:method)))" "(definterface ITreeNode\\n  (getValue [])\\n  (getMethod [])\\n  (getField [])\\n  (countMethods [])\\n  (countFields []))" "(definterface ITreeNode\\n  (getValue [])\\n  (getMethod [])\\n  (getField [])\\n  (getKind[])\\n  (countMethods [])\\n  (countFields []))" "(deftype TreeNode\\r\\n  [data]\\r\\n  ITreeNode\\n  (getValue [this] (force (data \:value)))\\n  (getMethod [this] (data \:method))\\n  (getField [this] (data \:method))\\n  (getKind [this]\\n           (cond\\n             (contains? data \:method) \:method\\r\\n             (contains? data \:field) \:field\\r\\n             (sequential? (data \:value)) \:sequence\\n             \:else \:object))\\n  (countMethods [this]\\n    (count (-> (this .getValue) .getClass .getMethods)))\\n  (countFields [this]\\n    (count (-> (this .getValue) .getClass .getDeclaredFields))\\n    ))" "(deftype TreeNode\\r\\n  [data]\\r\\n  ITreeNode\\n  (getValue [this] (force (data \:value)))\\n  (getMethod [this] (data \:method))\\n  (getField [this] (data \:method))\\n  (getKind [this]\\n           (cond\\n             (contains? data \:method) \:method\\r\\n             (contains? data \:field) \:field\\r\\n             (sequential? (data \:value)) \:sequence\\n             \:else \:object))\\n  (countMethods [this]\\n    (count (-> this .getValue .getClass .getMethods)))\\n  (countFields [this]\\n    (count (-> this .getValue .getClass .getDeclaredFields))\\n    ))" "(clojure.core/ns inspector-jay.core)\\n(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use\\n    [clojure.string \:only [split join]]\\n    [seesaw\\n     [core]\\n     [font]]\\n    [inspector-jay\\n     [tree-node \:only [object-node]]\\n     [tree-model]\\n     [tree-ui]])\\n  (\:import\\n    [scratchpad Test]))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.core)\\n(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\nNote that the object itself is also returned such that you can use this function anywhere without affecting the program's behaviour.\\"\\r\\n\\t(let [f (frame \:title (join [\\"Object inspector \: \\" (.toString object)]) \\n                \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (config\! f \:content split-pane)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.core)\\n(def options\\n  {\:width 640,\\n   \:height 480\\n   \:font (font \:name \:sans-serif \:style \#{\:plain})})\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.core)\\n(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\nNote that the object itself is also returned such that you can use this function anywhere without affecting the program's behaviour.\\"\\r\\n\\t(let [f (frame \:title (join [\\"Object inspector \: \\" (.toString object)]) \\n                \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (config\! f \:content split-pane)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.tree-model)\\n(ns inspector-jay.tree-model\\n  \\"Defines the tree structure of the object inspector\\"\\r\\n  {\:author \\"Tim Molderez\\"}\\n  (\:use \\n    [inspector-jay.tree-node])\\n  (\:import\\r\\n     [javax.swing.tree TreeModel]\\n     [java.lang.reflect Method]))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmulti is-leaf\\n  \\"Is this tree node a leaf?\\"\\n  node-kind)\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmulti get-child\\n  \\"Get the child of a node at a certain index\\"\\n  (fn [node index] (node-kind node)))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmulti get-child-count\\n  \\"Get the number of children of a node\\"\\n  node-kind)\\n(clojure.core/ns inspector-jay.tree-node)" ";; Switching to inspector-jay.tree-node namespace" "(clojure.core/ns inspector-jay.tree-model)\\n(defmulti is-leaf\\n  \\"Is this tree node a leaf?\\"\\n  node-kind)\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmulti is-leaf\\n  \\"Is this tree node a leaf?\\"\\n  (fn [node index] (-> node .getKind)))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmulti is-leaf\\n  \\"Is this tree node a leaf?\\"\\n  (fn [node] (-> node .getKind)))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmulti get-child\\n  \\"Get the child of a node at a certain index\\"\\n  (fn [node index] (-> node .getKind)))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmulti get-child-count\\n  \\"Get the number of children of a node\\"\\n  (fn [node] (-> node .getKind)))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod is-leaf \:object [node]\\r\\n  false)\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod is-leaf \:method [node]\\r\\n  (or\\n    (\= \\"void\\" (-> node .getMethod .getReturnType .getSimpleName)) \\n    (not\= 0 (count (-> node .getMethod .getParameterTypes)))))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod is-leaf \:field [node]\\r\\n  (or\\r\\n    (-> node .getField .getType .isPrimitive)\\r\\n    (\= (node \:value) nil)))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod is-leaf \:field [node]\\r\\n  (or\\r\\n    (-> node .getField .getType .isPrimitive)\\r\\n    (\= (-> node .getValue) nil)))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod is-leaf \:method [node]\\r\\n  (or\\n    (\= \\"void\\" (-> node .getMethod .getReturnType .getSimpleName)) \\n    (not\= 0 (count (-> node .getMethod .getParameterTypes)))))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod is-leaf \:field [node]\\r\\n  (or\\r\\n    (-> node .getField .getType .isPrimitive)\\r\\n    (\= (-> node .getValue) nil)))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod get-child \:default [node index]\\r\\n  (if (< index (num-of-methods (node \:value)))\\r\\n    (let\\r\\n      [meth (nth (-> node .getValue .getClass .getMethods) index)]\\n      (method-node meth (-> node .getValue)))\\r\\n    (let\\r\\n      [field-index (- index (num-of-methods (node \:value)))\\r\\n       field (nth (-> (node-class node) .getDeclaredFields) field-index)]\\r\\n      (-> field (.setAccessible true)) ; Enable access to private fields\\r\\n      {\:field field \:value (-> field (.get (node \:value))) \:parent node})))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod get-child \:default [node index]\\r\\n  (if (< index (-> node .countMethods)))\\r\\n    (let\\r\\n      [meth (nth (-> node .getValue .getClass .getMethods) index)]\\n      (method-node meth (-> node .getValue)))\\r\\n    (let\\r\\n      [field-index (- index (-> node .countMethods))\\r\\n       field (nth (-> node .getValue .getClass .getDeclaredFields) field-index)]\\r\\n      (-> field (.setAccessible true)) ; Enable access to private fields\\n      (field-node field (-> node .getValue))))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod get-child \:default [node index]\\r\\n  (if (< index (-> node .countMethods))\\r\\n    (let\\r\\n      [meth (nth (-> node .getValue .getClass .getMethods) index)]\\n      (method-node meth (-> node .getValue)))\\r\\n    (let\\r\\n      [field-index (- index (-> node .countMethods))\\r\\n       field (nth (-> node .getValue .getClass .getDeclaredFields) field-index)]\\r\\n      (-> field (.setAccessible true)) ; Enable access to private fields\\n      (field-node field (-> node .getValue))))\\n(clojure.core/ns inspector-jay.tree-node)" "(defmethod get-child \:default [node index]\\r\\n  (if (< index (-> node .countMethods))\\r\\n    (let\\r\\n      [meth (nth (-> node .getValue .getClass .getMethods) index)]\\n      (method-node meth (-> node .getValue)))\\r\\n    (let\\r\\n      [field-index (- index (-> node .countMethods))\\r\\n       field (nth (-> node .getValue .getClass .getDeclaredFields) field-index)]\\r\\n      (-> field (.setAccessible true)) ; Enable access to private fields\\n      (field-node field (-> node .getValue)))))" "(ns inspector-jay.tree-model\\n  \\"Defines the tree structure of the object inspector\\"\\r\\n  {\:author \\"Tim Molderez\\"}\\n  (\:use \\n    [inspector-jay.tree-node])\\n  (\:import\\r\\n     [javax.swing.tree TreeModel]\\n     [java.lang.reflect Method]))" "(defmethod get-child \:default [node index]\\r\\n  (if (< index (-> node .countMethods))\\r\\n    (let\\r\\n      [meth (nth (-> node .getValue .getClass .getMethods) index)]\\n      (method-node meth (-> node .getValue)))\\r\\n    (let\\r\\n      [field-index (- index (-> node .countMethods))\\r\\n       field (nth (-> node .getValue .getClass .getDeclaredFields) field-index)]\\r\\n      (-> field (.setAccessible true)) ; Enable access to private fields\\n      (field-node field (-> node .getValue)))))" "(defmethod get-child-count \:default [node]\\r\\n  (+ (-> node .countMethods) (-> node .countFields)))" "(defn tree-model ^TreeModel\\r\\n  [^Object rootObj]\\r\\n  \\"Define a tree model around rootObj, which is the object we want to inspect\\"\\r\\n  (proxy [TreeModel] []\\r\\n    (getRoot [] {\:value rootObj})\\r\\n    (addTreeModelListener [treeModelListener])\\r\\n    (getChild [parent index]\\r\\n      (get-child parent index))\\r\\n    (getChildCount [parent]\\r\\n       (get-child-count parent))\\r\\n    (isLeaf [node]\\r\\n      (is-leaf node))\\r\\n    (valueForPathChanged [path newValue])\\r\\n    (getIndexOfChild [parent child] -1)\\r\\n    (removeTreeModelListener [treeModelListener])))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmulti to-string\\n  \\"Retrieve a short description of a tree node\\"\\n  (fn [node] (-> node .getKind)))\\n(clojure.core/ns inspector-jay.tree-model)" "(clojure.core/ns inspector-jay.tree-ui)\\n(ns inspector-jay.tree-ui\\n  \\"Defines how each tree node is displayed in the GUI\\"\\n  {\:author \\"Tim Molderez\\"}\\n  (\:use \\n    [clojure.string \:only [split join]]\\n    [clojure.java.io \:only [resource]]\\n    [seesaw.core]\\n    [inspector-jay.tree-node])\\r\\n  (\:import\\r\\n     [java.awt.event ActionEvent ActionListener]\\n     [javax.swing JTextArea]\\r\\n     [javax.swing.tree DefaultTreeCellRenderer]\\r\\n     [javax.swing.event TreeSelectionListener]\\r\\n     [java.lang.reflect Modifier]))\\n(clojure.core/ns inspector-jay.tree-model)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmulti to-string\\n  \\"Retrieve a short description of a tree node\\"\\n  (fn [node] (-> node .getKind)))\\n(clojure.core/ns inspector-jay.tree-model)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmulti to-string-verbose\\n  \\"Retrieve a detailed description of a tree node\\"\\n  (fn [node] (-> node .getKind)))\\n(clojure.core/ns inspector-jay.tree-model)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmulti get-icon\\n  \\"Retrieve the icon associated with a tree node\\"\\n  (fn [node] (-> node .getKind)))\\n(clojure.core/ns inspector-jay.tree-model)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string \:object [node]\\n  (-> node .getValue .toString))\\n(clojure.core/ns inspector-jay.tree-model)" "(clojure.core/ns inspector-jay.tree-ui)\\n(ns inspector-jay.tree-ui\\n  \\"Defines how each tree node is displayed in the GUI\\"\\n  {\:author \\"Tim Molderez\\"}\\n  (\:use \\n    [clojure.string \:only [split join]]\\n    [clojure.java.io \:only [resource]]\\n    [seesaw.core]\\n    [inspector-jay.tree-node])\\r\\n  (\:import\\r\\n     [java.awt.event ActionEvent ActionListener]\\n     [javax.swing JTextArea]\\r\\n     [javax.swing.tree DefaultTreeCellRenderer]\\r\\n     [javax.swing.event TreeSelectionListener]\\r\\n     [java.lang.reflect Modifier]))\\n\\n(defmulti to-string\\n  \\"Retrieve a short description of a tree node\\"\\n  (fn [node] (-> node .getKind)))\\n(defmulti to-string-verbose\\n  \\"Retrieve a detailed description of a tree node\\"\\n  (fn [node] (-> node .getKind)))\\r\\n(defmulti get-icon\\n  \\"Retrieve the icon associated with a tree node\\"\\n  (fn [node] (-> node .getKind)))\\r\\n\\r\\n(defmethod to-string \:object [node]\\n  (-> node .getValue .toString))\\r\\n\\n(clojure.core/ns inspector-jay.tree-model)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string \:method [node]\\r\\n  (join [ \\"<html>\\"\\r\\n         (-> node .getMethod .getName)\\r\\n         \\"(\\"\\r\\n         (join (interpose \\", \\" (map (memfn getSimpleName) (-> node .getMethod .getParameterTypes))))\\r\\n         \\") \: \\"\\r\\n         (-> node .getMethod .getReturnType .getSimpleName)\\r\\n         \\"</html>\\"]))\\n(clojure.core/ns inspector-jay.tree-model)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod get-icon \:default [node]\\r\\n  (icon (resource \\"icons/file_obj.gif\\")))\\n(clojure.core/ns inspector-jay.tree-model)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod get-icon \:method [node]\\r\\n  (let\\r\\n    [mod (-> node .getMethod .getModifiers)]\\r\\n  (cond\\r\\n    (Modifier/isPublic mod) (icon (resource \\"icons/methpub_obj.gif\\"))\\r\\n    (Modifier/isPrivate mod) (icon (resource \\"icons/methpri_obj.gif\\"))\\r\\n    (Modifier/isPrivate mod) (icon (resource \\"icons/methpro_obj.gif\\"))\\r\\n    \:else (icon (resource \\"icons/methdef_gif.gif\\")))))\\n(clojure.core/ns inspector-jay.tree-model)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string \:field [node]\\r\\n  (join [ \\"<html>\\"\\r\\n         (-> node .getField .getName)\\r\\n         \\" \: \\"\\r\\n         (-> node .getValue)\\r\\n         \\"</html>\\"]))\\n(clojure.core/ns inspector-jay.tree-model)" ";; Switching to inspector-jay.core namespace" ";; Switching to inspector-jay.tree-node namespace" "(object-node (new Object))" "(.getValue (object-node (new Object)))" "(.getClass (.getValue (object-node (new Object))))" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.core)\\n(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\nNote that the object itself is also returned such that you can use this function anywhere without affecting the program's behaviour.\\"\\r\\n\\t(let [f (frame \:title (join [\\"Object inspector \: \\" (.toString object)]) \\n                \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree nil\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (config\! f \:content split-pane)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.core)\\n(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\nNote that the object itself is also returned such that you can use this function anywhere without affecting the program's behaviour.\\"\\r\\n\\t(let [f (frame \:title (join [\\"Object inspector \: \\" (.toString object)]) \\n                \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text \\"hello\\" \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (config\! f \:content split-pane)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))\\n(clojure.core/ns inspector-jay.tree-node)" "(clojure.core/ns inspector-jay.core)\\nnull\\n(clojure.core/ns inspector-jay.tree-node)" "(to-string-verbose (object-node object))" ";; Switching to inspector-jay.core namespace" "(to-string-verbose (object-node object))" "(to-string-verbose (object-node (new Object)))" "(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\nNote that the object itself is also returned such that you can use this function anywhere without affecting the program's behaviour.\\"\\r\\n\\t(let [f (frame \:title (join [\\"Object inspector \: \\" (.toString object)]) \\n                \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (config\! f \:content split-pane)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))" "(inspect (new Test))" "(inspect 5)" "(e)" "(inspect (new Test))" "(e)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod is-leaf \:field [node]\\n  (println node .getValue)\\r\\n  (or\\r\\n    (-> node .getField .getType .isPrimitive)\\r\\n    (\= (-> node .getValue) nil)))\\n(clojure.core/ns inspector-jay.core)" "(e)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn method-node\\n  [method object]\\n  (new TreeNode {\:method method \:value (delay (\\n                                                let( [bla 5]\\n                                                     (println method)\\n                                                     (invoke-method method object))))}))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn method-node\\n  [method object]\\n  (new TreeNode {\:method method \:value (delay (\\n                                                let( [bla 5]\\n                                                     \\n                                                     (invoke-method method object))))}))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn method-node\\n  [method object]\\n  (new TreeNode {\:method method \:value (delay (\\n                                                (let [bla 5]\\n                                                     (println method)\\n                                                     (invoke-method method object))))}))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn method-node\\n  [method object]\\n  (new TreeNode {\:method method \:value (delay (\\n                                                (let [bla 5]\\n                                                  (println \\"hello\\")   \\n                                                  (println object)\\n                                                     (invoke-method method object))))}))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn method-node\\n  [method object]\\n  (new TreeNode {\:method method \:value (delay (\\n                                                (let [bla 5]\\n                                                  (println \\"hello\\")   \\n                                                  (println object)\\n                                                  (println method)\\n                                                  (println \\"---\\")\\n                                                     (invoke-method method object))))}))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method ^Object\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value\\"\\n  (println method)\\n  (println object)\\r\\n  (-> method (.invoke object)))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method ^Object\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value\\"\\n  (new Object))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method ^Object\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value\\"\\n  (println method)\\n  (println object)\\n  (new Object))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method ^Object\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value\\"\\n  (println method)\\n  (println object)\\n  (-> method .getDefaultValue))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method ^Object\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value\\"\\n  (println method)\\n  (println object)\\n  (println (-> method .getDefaultValue))\\n  (new Object))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method ^Object\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value\\"\\n  (println method)\\n  (println object)\\n  (println (-> method .invoke))\\n  (new Object))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(ns inspector-jay.tree-node\\n  \\"Defines the data structure of a tree node\\"\\r\\n  {\:author \\"Tim Molderez\\"}\\n  (\:import\\r\\n     [java.lang.reflect Method]))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value\\"\\n  (println method)\\n  (println object)\\n  (println (-> method .getName))\\n  (new Object))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value\\"\\n  (println method)\\n  (println object)\\n  (println (-> method .getModifiers))\\n  (new Object))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value\\"\\n  (println method)\\n  (println object)\\n  (println (-> method (.invoke 5)))\\n  (new Object))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn method-node\\n  [method object]\\n  (new TreeNode {\:method method \:value (invoke-method method object)}))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(first (-> (new Object) .getMethods))" "(first (-> (new Object) .getClass .getMethods))" "(def meth (first (-> (new Object) .getClass .getMethods)))" "(-> meth .invoke)" "(.invoke meth)" "(-> (new Object) meth)" "(.setAccessible meth true)" "(.invoke meth)" "(.invoke meth (new Object))" "(-> meth .toString 34)" "(-> meth .toString)" "(-> meth .isAccessible)" "(.invoke meth (new Object))" "(use clojure.contrib.reflect)" "(use 'clojure.contrib.reflect)" "(use '(clojure.contrib reflect))" "(def meth (first (-> (new Object) .getClass .getDeclaredMethods)))" "meth" "(.invoke meth)" "(.invoke meth (new Object))" "(meth .getMethods)" "(for [x (.getMethods meth)]\\r\\n         (println x))" "(for [x (.getClass (.getMethods meth))]\\r\\n         (println x))" "(for [x (.getMethods (.getClass meth))]\\r\\n         (println x))" "(.invoke meth (new Object) nil)" "(.invoke meth (new Object))" "(.invoke meth (new Object) 5)" "(.invoke meth (new Object) [])" "(.invoke meth (new Object) {})" "(.invoke meth (new Object) (to-array []))" "(.invoke meth (new Test) (to-array []))" "(.invoke meth (new Test) (new Object))" "(.invoke meth (new Test) nil)" "(.invoke meth (new Test) 456)" "(def meth (first (-> (new Object) .getClass .getDeclaredMethods)))" "meth" "(def meth (nth (-> (new Object) .getClass .getDeclaredMethods) 1))" "meth" "(def meth (nth (-> (new Object) .getClass .getDeclaredMethods) 2))" "meth" "(.invoke meth (new Object) (to-array []))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value\\"\\n;  (println method)\\n;  (println object)\\n;  (println (-> method (.invoke 5)))\\n;  (new Object))\\r\\n  (-> method (.invoke object (to-array []))))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn method-node\\n  [method object]\\n  (if (\= 0 (count (-> method .getParameterTypes)))\\n    (new TreeNode {\:method method \:value (delay (invoke-method method object))})\\n    (new TreeNode {\:method method \:value nil}))\\n(clojure.core/ns inspector-jay.core)" "(defn method-node\\n  [method object]\\n  (if (\= 0 (count (-> method .getParameterTypes)))\\n    (new TreeNode {\:method method \:value (delay (invoke-method method object))})\\n    (new TreeNode {\:method method \:value nil})))" "(defn invoke-method\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value\\nTODO\: Only supports methods with no parameters, for now..\\"\\n;  (println method)\\n;  (println object)\\n;  (println (-> method (.invoke 5)))\\n;  (new Object))\\r\\n  (-> method (.invoke object)))" "(defn invoke-method\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value\\nTODO\: Only supports methods with no parameters, for now..\\"\\n;  (println method)\\n;  (println object)\\n;  (println (-> method (.invoke 5)))\\n;  (new Object))\\r\\n  (-> method (.invoke object nil)))" "(clojure.core/ns inspector-jay.core)\\n(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\nNote that the object itself is also returned such that you can use this function anywhere without affecting the program's behaviour.\\"\\r\\n\\t(let [f (frame \:title (join [\\"Object inspector \: \\" (.toString object)]) \\n                \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (config\! f \:content split-pane)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))\\n(clojure.core/ns inspector-jay.tree-node)" "(defn method-node\\n  [method object]\\n  (if \\n    (and\\n      (not\= \\"void\\" (-> method .getReturnType .getSimpleName)) \\n      (\= 0 (count (-> method .getParameterTypes))))\\n    (new TreeNode {\:method method \:value (delay (invoke-method method object))})\\n    (new TreeNode {\:method method \:value nil})))" "(clojure.core/ns inspector-jay.core)\\n(inspect (new Test))\\n(clojure.core/ns inspector-jay.tree-node)" "(inspect 5)" ";; Switching to inspector-jay.core namespace" "(inspect 5)" "(inspect 5.0)" "(inspect \\"dksd\\")" "(inspect inspect)" "(inspect map)" "(inspect [1 2])" "(inspect (new Vector))" "(inspect (new java.lang.Vector))" "(inspect (new Test))" "(inspect [1 2 3])" ";; Switching to inspector-jay.core namespace" "(inspect [1 [2 3]])" "(new Test)" "(def test (new Test))" "(.setVec test)" "(inspect test)" "test" "(def test (new Test))" "(inspect test)" "(clojure.core/ns inspector-jay.tree-node)\\nnull\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn get-visible-fields [object]\\n  (let\\n    [declFields (-> object .getClass .getDeclaredMethods)]\\n    true)\\n  )\\n(clojure.core/ns inspector-jay.core)" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod get-icon \:field [node]\\r\\n  (let\\r\\n    [mod (-> node .getField .getModifiers)]\\r\\n  (cond\\r\\n    (Modifier/isPublic mod) (icon (resource \\"icons/field_public_obj.gif\\"))\\r\\n    (Modifier/isPrivate mod) (icon (resource \\"icons/field_private_obj.gif\\"))\\r\\n    (Modifier/isProtected mod) (icon (resource \\"icons/field_protected_obj.gif\\"))\\r\\n    \:else (icon (resource \\"icons/field_default_obj.gif\\")))))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(and true true)" "(and [true true])" "(and [true false])" "(apply and [true false])" "(clojure.core/ns inspector-jay.tree-node)\\n(defn get-visible-fields [cls]\\n  (let\\n    [declFields (-> cls .getDeclaredMethods)\\n     ancestorFields (if (\= java.lang.Object cls)\\n                      []\\n                      (get-visible-fields (-> cls .getSuperclass)))]\\n    (filter (fn [aField]\\n              (every? (fn [dField] (not\= (-> dField .getName) (-> aField .getName)))\\n                      declFields))\\n      ancestorFields)\\n    )\\n  )\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn get-visible-fields [cls]\\n  (let\\n    [declFields (-> cls .getDeclaredMethods)\\n     ancestorFields (if (\= java.lang.Object cls)\\n                      []\\n                      (get-visible-fields (-> cls .getSuperclass)))\\n     filteredAncestors (filter (fn [aField]\\n                                 (and\\n                                   (not (Modifier/isPrivate (-> aField .getModifiers)))\\n                                   (every? (fn [dField] (not\= (-> dField .getName) (-> aField .getName)))\\n                                         declFields))\\n                               ancestorFields))]\\n    \\n    )\\n  )\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(ns inspector-jay.tree-node\\n  \\"Defines the data structure of a tree node\\"\\r\\n  {\:author \\"Tim Molderez\\"}\\n  (\:import\\r\\n     [java.lang.reflect Method]\\n     [java.lang.reflect Modifier]))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn get-visible-fields [cls]\\n  (let\\n    [declFields (-> cls .getDeclaredMethods)\\n     ancestorFields (if (\= java.lang.Object cls)\\n                      []\\n                      (get-visible-fields (-> cls .getSuperclass)))\\n     filteredAncestors (filter (fn [aField]\\n                                 (and\\n                                   (not (Modifier/isPrivate (-> aField .getModifiers)))\\n                                   (every? (fn [dField] (not\= (-> dField .getName) (-> aField .getName)))\\n                                         declFields))\\n                               ancestorFields))]\\n    \\n    )\\n  )\\n(clojure.core/ns inspector-jay.core)" ";; Switching to inspector-jay.tree-node namespace" "(get-visible-fields Test)" "(defn get-visible-fields [cls]\\n  (let\\n    [declFields (-> cls .getDeclaredMethods)\\n     ancestorFields (if (\= java.lang.Object cls)\\n                      []\\n                      (get-visible-fields (-> cls .getSuperclass)))\\n     filteredAncestors (filter (fn [aField]\\n                                 (and\\n                                   (not (Modifier/isPrivate (-> aField .getModifiers)))\\n                                   (every? (fn [dField] (not\= (-> dField .getName) (-> aField .getName)))\\n                                         declFields)))\\n                               ancestorFields)]\\n    \\n    )\\n  )" "(get-visible-fields Test)" "(defn get-visible-fields [cls]\\n  (let\\n    [declFields (-> cls .getDeclaredMethods)\\n     ancestorFields (if (\= java.lang.Object cls)\\n                      []\\n                      (get-visible-fields (-> cls .getSuperclass)))\\n     filteredAncestors (filter (fn [aField]\\n                                 (and\\n                                   (not (Modifier/isPrivate (-> aField .getModifiers)))\\n                                   (every? (fn [dField] (not\= (-> dField .getName) (-> aField .getName)))\\n                                         declFields)))\\n                               ancestorFields)]\\n    (concat declFields filteredAncestors))\\n  )" "(get-visible-fields Test)" "(defn get-visible-fields [cls]\\n  (let\\n    [declFields (-> cls .getDeclaredFields)\\n     ancestorFields (if (\= java.lang.Object cls)\\n                      []\\n                      (get-visible-fields (-> cls .getSuperclass)))\\n     filteredAncestors (filter (fn [aField]\\n                                 (and\\n                                   (not (Modifier/isPrivate (-> aField .getModifiers)))\\n                                   (every? (fn [dField] (not\= (-> dField .getName) (-> aField .getName)))\\n                                         declFields)))\\n                               ancestorFields)]\\n    (concat declFields filteredAncestors))\\n  )" "(get-visible-fields Test)" "(-> (new Object) .getClass .getMethods)" "(\= [1 2 3] [3 2 1])" "(\= [1 2 3] [1 2 3])" "(\= [Object] [Object])" "(\= [Object Test] [Object (.getClass (new Test))])" "(defn get-visible-methods [cls]\\n  \\"Retrieve all methods that are visible to any instances of class cls.\\nMore specifically, all methods declared directly in cls, and all public/protected methods found in its ancestor classes.\\"\\n  (let\\n    ; All methods declared directly in cls\\n    [declMethods (-> cls .getDeclaredMethods)\\n     ; All methods declared in the ancestor classes of cls\\n     ancestorMethods (if (\= java.lang.Object cls)\\n                      []\\n                      (get-visible-methods (-> cls .getSuperclass)))\\n     ; Remove all private and hidden methods from ancestorMethods\\n     filteredAncestors (filter (fn [aMethod]\\n                                 (and\\n                                   (not (Modifier/isPrivate (-> aMethod .getModifiers)))\\n                                   (every? (fn [dMethod]\\n                                             (and\\n                                               (not\= (-> dMethod .getName) (-> aMethod .getName))\\n                                               (not\= (-> dMethod .getParameterTypes) (-> aMethod .getParameterTypes))))\\n                                         declMethods)))\\n                               ancestorMethods)]\\n    (concat declFields filteredAncestors)))" "(defn get-visible-methods [cls]\\n  \\"Retrieve all methods that are visible to any instances of class cls.\\nMore specifically, all methods declared directly in cls, and all public/protected methods found in its ancestor classes.\\"\\n  (let\\n    ; All methods declared directly in cls\\n    [declMethods (-> cls .getDeclaredMethods)\\n     ; All methods declared in the ancestor classes of cls\\n     ancestorMethods (if (\= java.lang.Object cls)\\n                      []\\n                      (get-visible-methods (-> cls .getSuperclass)))\\n     ; Remove all private and hidden methods from ancestorMethods\\n     filteredAncestors (filter (fn [aMethod]\\n                                 (and\\n                                   (not (Modifier/isPrivate (-> aMethod .getModifiers)))\\n                                   (every? (fn [dMethod]\\n                                             (and\\n                                               (not\= (-> dMethod .getName) (-> aMethod .getName))\\n                                               (not\= (-> dMethod .getParameterTypes) (-> aMethod .getParameterTypes))))\\n                                         declMethods)))\\n                               ancestorMethods)]\\n    (concat declMethods filteredAncestors)))" "(get-visible-methods Test)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod get-child \:default [node index]\\r\\n  (if (< index (-> node .countMethods))\\r\\n    (let\\r\\n      [meth (nth (-> node .getMethods) index)]\\n      (method-node meth (-> node .getValue)))\\r\\n    (let\\r\\n      [field-index (- index (-> node .countMethods))\\r\\n       field (nth (-> node .getFields) field-index)]\\r\\n      (-> field (.setAccessible true)) ; Enable access to private fields\\n      (field-node field (-> node .getValue)))))\\n(clojure.core/ns inspector-jay.tree-node)" ";; Switching to inspector-jay.core namespace" "(inspect (new Object))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod get-icon \:method [node]\\r\\n  (let\\r\\n    [mod (-> node .getMethod .getModifiers)]\\r\\n  (cond\\r\\n    (Modifier/isPublic mod) (icon (resource \\"icons/methpub_obj.gif\\"))\\r\\n    (Modifier/isPrivate mod) (icon (resource \\"icons/methpri_obj.gif\\"))\\r\\n    (Modifier/isProtected mod) (icon (resource \\"icons/methpro_obj.gif\\"))\\r\\n    \:else (icon (resource \\"icons/methdef_gif.gif\\")))))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Object))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" "(e)" "(clojure.core/ns inspector-jay.tree-node)\\n(deftype TreeNode\\r\\n  [data]\\r\\n  ITreeNode\\n  (getValue [this] \\n    (force (data \:value)))\\n  (hasValue [this] \\n    (or\\n      (not (contains? data \:value))\\n      (\= (data \:value) nil)))\\n  (getMethod [this]\\n    (data \:method))\\n  (getField [this]\\n    (data \:field))\\n  (getMethods [this]\\n    (get-visible-methods (-> this .getValue .getClass)))\\n  (getFields [this]\\n    (get-visible-fields (-> this .getValue .getClass)))\\n  (getKind [this]\\n    (cond\\n      (sequential? (data \:value)) \:sequence\\n      (contains? data \:method) \:method\\r\\n      (contains? data \:field) \:field\\n      \:else \:object))\\n  (countMethods [this]\\n    (count (-> this .getMethods)))\\n  (countFields [this]\\n    (count (-> this .getFields))))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(deftype TreeNode\\r\\n  [data]\\r\\n  ITreeNode\\n  (getValue [this] \\n    (force (data \:value)))\\n  (hasValue [this] \\n    (and\\n      (contains? data \:value))\\n      (not\= (data \:value) nil))\\n  (getMethod [this]\\n    (data \:method))\\n  (getField [this]\\n    (data \:field))\\n  (getMethods [this]\\n    (get-visible-methods (-> this .getValue .getClass)))\\n  (getFields [this]\\n    (get-visible-fields (-> this .getValue .getClass)))\\n  (getKind [this]\\n    (cond\\n      (sequential? (data \:value)) \:sequence\\n      (contains? data \:method) \:method\\r\\n      (contains? data \:field) \:field\\n      \:else \:object))\\n  (countMethods [this]\\n    (count (-> this .getMethods)))\\n  (countFields [this]\\n    (count (-> this .getFields))))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(deftype TreeNode\\r\\n  [data]\\r\\n  ITreeNode\\n  (getValue [this] \\n    (force (data \:value)))\\n  (hasValue [this] \\n    (and\\n      (contains? data \:value))\\n      (not\= (data \:value) nil))\\n  (getMethod [this]\\n    (data \:method))\\n  (getField [this]\\n    (data \:field))\\n  (getMethods [this]\\n    (get-visible-methods (-> this .getValue .getClass)))\\n  (getFields [this]\\n    (get-visible-fields (-> this .getValue .getClass)))\\n  (getKind [this]\\n    (cond\\n      (sequential? (data \:value)) \:sequence\\n      (contains? data \:method) \:method\\r\\n      (contains? data \:field) \:field\\n      \:else \:object))\\n  (countMethods [this]\\n    (count (-> this .getMethods)))\\n  (countFields [this]\\n    (count (-> this .getFields))))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod get-icon \:method [node]\\r\\n  (let\\r\\n    [mod (-> node .getMethod .getModifiers)]\\r\\n  (cond\\r\\n    (Modifier/isPublic mod) (icon (resource \\"icons/methpub_obj.gif\\"))\\r\\n    (Modifier/isPrivate mod) (icon (resource \\"icons/methpri_obj.gif\\"))\\r\\n    (Modifier/isProtected mod) (icon (resource \\"icons/methpro_obj.gif\\"))\\r\\n    \:else (icon (resource \\"icons/methdef_obj.gif\\")))))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn method-node\\n  [method object]\\n  (if \\n    (and\\n      (not (Modifier/isNative (-> method .getModifiers)))\\n      (not\= \\"void\\" (-> method .getReturnType .getSimpleName)) \\n      (\= 0 (count (-> method .getParameterTypes))))\\n    (let []\\n      (-> field (.setAccessible true)) ; Enable access to private fields)\\n      (new TreeNode {\:method method \:value (delay (invoke-method method object))}))\\n    (new TreeNode {\:method method \:value nil})))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn method-node\\n  [method object]\\n  (if \\n    (and\\n      (not (Modifier/isNative (-> method .getModifiers)))\\n      (not\= \\"void\\" (-> method .getReturnType .getSimpleName)) \\n      (\= 0 (count (-> method .getParameterTypes))))\\n    (let []\\n      (-> method (.setAccessible true)) ; Enable access to private methods\\n      (new TreeNode {\:method method \:value (delay (invoke-method method object))}))\\n    (new TreeNode {\:method method \:value nil})))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn field-node\\n  [field object]\\n  (-> field (.setAccessible true)) ; Enable access to private fields\\n  (new TreeNode {\:field field \:value (-> field (.get object))}))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn method-node\\n  [method object]\\n  (if \\n    (and\\n      false\\n      (not (Modifier/isNative (-> method .getModifiers)))\\n      (not\= \\"void\\" (-> method .getReturnType .getSimpleName)) \\n      (\= 0 (count (-> method .getParameterTypes))))\\n    (let []\\n      (-> method (.setAccessible true)) ; Enable access to private methods\\n      (new TreeNode {\:method method \:value (delay (invoke-method method object))}))\\n    (new TreeNode {\:method method \:value nil})))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" "(inspect (frame))" "(frame)" "(inspect 5)" ";; Switching to inspector-jay.core namespace" "(label \\"hello\\")" "(inspect (label \\"hello\\"))" ";; Switching to inspector-jay.core namespace" "(inspect 5)" "(inspect max)" "(inspect \\"hello\\")" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use\\n    [clojure.stacktrace]\\n    [clojure.string \:only [split join]]\\n    [seesaw\\n     [core]\\n     [font]]\\n    [inspector-jay\\n     [tree-node \:only [object-node]]\\n     [tree-model]\\n     [tree-ui]])\\n  (\:import\\n    [scratchpad Test]\\n    [javax.swing JPanel]))" "(inspect (new JPanel))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn get-visible-methods [cls]\\r\\n  \\"Retrieve all methods that are visible to any instances of class cls.\\r\\nMore specifically, all methods declared directly in cls, and all public/protected methods found in its ancestor classes.\\"\\r\\n  (println cls)\\n  (let\\r\\n    ; All methods declared directly in cls\\r\\n    [declMethods (-> cls .getDeclaredMethods)\\r\\n     ; All methods declared in the ancestor classes of cls\\r\\n     ancestorMethods (if (\= java.lang.Object cls)\\r\\n                      []\\r\\n                      (get-visible-methods (-> cls .getSuperclass)))\\r\\n     ; Remove all private and hidden methods from ancestorMethods\\r\\n     filteredAncestors (filter (fn [aMethod]\\r\\n                                 (and\\r\\n                                   (not (Modifier/isPrivate (-> aMethod .getModifiers)))\\n                                   (not (Modifier/isNative (-> aMethod .getModifiers)))\\r\\n                                   (every? (fn [dMethod]\\r\\n                                             (and\\r\\n                                               (not\= (-> dMethod .getName) (-> aMethod .getName))\\r\\n                                               (not\= (-> dMethod .getParameterTypes) (-> aMethod .getParameterTypes))))\\r\\n                                         declMethods)))\\r\\n                               ancestorMethods)]\\r\\n    (concat declMethods filteredAncestors)))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new JPanel))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn get-visible-methods [cls]\\r\\n  \\"Retrieve all methods that are visible to any instances of class cls.\\r\\nMore specifically, all methods declared directly in cls, and all public/protected methods found in its ancestor classes.\\"\\n  (let\\r\\n    ; All methods declared directly in cls\\r\\n    [declMethods (-> cls .getDeclaredMethods)\\r\\n     ; All methods declared in the ancestor classes of cls\\r\\n     ancestorMethods (if (\= java.lang.Object cls)\\r\\n                      []\\r\\n                      (get-visible-methods (-> cls .getSuperclass)))\\r\\n     ; Remove all private and hidden methods from ancestorMethods\\r\\n     filteredAncestors (filter (fn [aMethod]\\r\\n                                 (and\\r\\n                                   (not (Modifier/isPrivate (-> aMethod .getModifiers)))\\n                                   (not (Modifier/isNative (-> aMethod .getModifiers)))\\r\\n                                   (every? (fn [dMethod]\\r\\n                                             (and\\r\\n                                               (not\= (-> dMethod .getName) (-> aMethod .getName))\\r\\n                                               (not\= (-> dMethod .getParameterTypes) (-> aMethod .getParameterTypes))))\\r\\n                                         declMethods)))\\r\\n                               ancestorMethods)]\\r\\n    (concat declMethods filteredAncestors)))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod get-child \:default [node index]\\n  (println node)\\r\\n  (if (< index (-> node .countMethods))\\r\\n    (let\\r\\n      [meth (nth (-> node .getMethods) index)]\\n      (method-node meth (-> node .getValue)))\\r\\n    (let\\r\\n      [field-index (- index (-> node .countMethods))\\r\\n       field (nth (-> node .getFields) field-index)]\\n      (field-node field (-> node .getValue)))))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new JPanel))" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod get-child \:default [node index]\\n  (println index)\\r\\n  (if (< index (-> node .countMethods))\\r\\n    (let\\r\\n      [meth (nth (-> node .getMethods) index)]\\n      (method-node meth (-> node .getValue)))\\r\\n    (let\\r\\n      [field-index (- index (-> node .countMethods))\\r\\n       field (nth (-> node .getFields) field-index)]\\n      (field-node field (-> node .getValue)))))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new JPanel))" ";; Switching to inspector-jay.core namespace" "(clojure.core/ns inspector-jay.tree-node)\\n(def get-visible-fields (memoize get-visible-fields-slow))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn get-visible-fields-slow [cls]\\r\\n  \\"Retrieve all fields that are visible to any instances of class cls.\\r\\nMore specifically, all fields declared directly in cls, and all public/protected fields found in its ancestor classes.\\"\\r\\n  (let\\r\\n    ; All fields declared directly in cls\\r\\n    [declFields (-> cls .getDeclaredFields)\\r\\n     ; All fields declared in the ancestor classes of cls\\r\\n     ancestorFields (if (\= java.lang.Object cls)\\r\\n                      []\\r\\n                      (get-visible-fields (-> cls .getSuperclass)))\\r\\n     ; Remove all private and hidden fields from ancestorFields\\r\\n     filteredAncestors (filter (fn [aField]\\r\\n                                 (and\\r\\n                                   (not (Modifier/isPrivate (-> aField .getModifiers)))\\n                                   (not (Modifier/isNative (-> aField .getModifiers)))\\r\\n                                   (every? (fn [dField] (not\= (-> dField .getName) (-> aField .getName)))\\r\\n                                         declFields)))\\r\\n                               ancestorFields)]\\r\\n    (concat declFields filteredAncestors)))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(ns inspector-jay.tree-node\\n  \\"Defines the data structure of a tree node\\"\\r\\n  {\:author \\"Tim Molderez\\"}\\n  (\:import\\r\\n     [java.lang.reflect Method]\\n     [java.lang.reflect Modifier]\\n     [scratchpad Test]))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn get-visible-fields-slow [cls]\\r\\n  \\"Retrieve all fields that are visible to any instances of class cls.\\r\\nMore specifically, all fields declared directly in cls, and all public/protected fields found in its ancestor classes.\\"\\r\\n  (let\\r\\n    ; All fields declared directly in cls\\r\\n    [declFields (-> cls .getDeclaredFields)\\r\\n     ; All fields declared in the ancestor classes of cls\\r\\n     ancestorFields (if (\= java.lang.Object cls)\\r\\n                      []\\r\\n                      (get-visible-fields (-> cls .getSuperclass)))\\r\\n     ; Remove all private and hidden fields from ancestorFields\\r\\n     filteredAncestors (filter (fn [aField]\\r\\n                                 (and\\r\\n                                   (not (Modifier/isPrivate (-> aField .getModifiers)))\\n                                   (not (Modifier/isNative (-> aField .getModifiers)))\\r\\n                                   (every? (fn [dField] (not\= (-> dField .getName) (-> aField .getName)))\\r\\n                                         declFields)))\\r\\n                               ancestorFields)]\\r\\n    (concat declFields filteredAncestors)))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(def get-visible-fields (memoize get-visible-fields-slow))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn get-visible-methods-slow [cls]\\r\\n  \\"Retrieve all methods that are visible to any instances of class cls.\\r\\nMore specifically, all methods declared directly in cls, and all public/protected methods found in its ancestor classes.\\"\\n  (let\\r\\n    ; All methods declared directly in cls\\r\\n    [declMethods (-> cls .getDeclaredMethods)\\r\\n     ; All methods declared in the ancestor classes of cls\\r\\n     ancestorMethods (if (\= java.lang.Object cls)\\r\\n                      []\\r\\n                      (get-visible-methods (-> cls .getSuperclass)))\\r\\n     ; Remove all private and hidden methods from ancestorMethods\\r\\n     filteredAncestors (filter (fn [aMethod]\\r\\n                                 (and\\r\\n                                   (not (Modifier/isPrivate (-> aMethod .getModifiers)))\\n                                   (not (Modifier/isNative (-> aMethod .getModifiers)))\\r\\n                                   (every? (fn [dMethod]\\r\\n                                             (and\\r\\n                                               (not\= (-> dMethod .getName) (-> aMethod .getName))\\r\\n                                               (not\= (-> dMethod .getParameterTypes) (-> aMethod .getParameterTypes))))\\r\\n                                         declMethods)))\\r\\n                               ancestorMethods)]\\r\\n    (concat declMethods filteredAncestors)))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(declare get-visible-fields)\\n(clojure.core/ns inspector-jay.core)" ";; Switching to inspector-jay.core namespace" "(inspect (new Object))" "(inspect (new JPanel))" "(inspect (new Test))" "(get-visible-fields (new Object))" ";; Switching to inspector-jay.core namespace" "(get-visible-fields (new Object))" ";; Switching to inspector-jay.tree-node namespace" "(get-visible-fields (new Object))" "(get-visible-fields-raw (new Object))" "(get-visible-fields-raw (.getClass (new Object)))" "(defn get-visible-fields [cls]\\r\\n  \\"Retrieve all fields that are visible to any instances of class cls.\\r\\nMore specifically, all fields declared directly in cls, and all public/protected fields found in its ancestor classes.\\"\\r\\n  (let\\r\\n    ; All fields declared directly in cls\\r\\n    [declFields (-> cls .getDeclaredFields)\\r\\n     ; All fields declared in the ancestor classes of cls\\r\\n     ancestorFields (if (\= java.lang.Object cls)\\r\\n                      []\\r\\n                      (get-visible-fields (-> cls .getSuperclass)))\\r\\n     ; Remove all private and hidden fields from ancestorFields\\r\\n     filteredAncestors (filter (fn [aField]\\r\\n                                 (and\\r\\n                                   (not (Modifier/isPrivate (-> aField .getModifiers)))\\n                                   (not (Modifier/isNative (-> aField .getModifiers)))\\r\\n                                   (every? (fn [dField] (not\= (-> dField .getName) (-> aField .getName)))\\r\\n                                         declFields)))\\r\\n                               ancestorFields)]\\r\\n    (concat declFields filteredAncestors)))" "(get-visible-fields (.getClass (new Object)))" "(get-visible-methods (.getClass (new Object)))" "(get-visible-methods-mem (.getClass (new Object)))" "(memoize (get-visible-methods))" "(memoize get-visible-methods)" "(defn bla [a b]\\n  (println \\"hey\\")\\n  (+ a b))" "(def bla-mem (memoize bla))" "(bla-mem 5 65)" "(defn bla [a b]\\n  (new Object))" "(defn bla []\\n  (new Object))" "(def bla-mem (memoize bla))" "(bla-mem)" "(defn make-fibo [y]\\r\\n  (with-local-vars\\r\\n      [fib (memoize\\r\\n            (fn [x]\\r\\n              (if (< x 2)\\r\\n                y\\r\\n                (+ (fib (- x 2)) (fib (dec x))))))]\\r\\n    (.bindRoot fib @fib)\\r\\n    @fib))" "(make-fibo 5)" "(make-fibo)" "(def fib (memoize (fn [x] (if (< x 2)\\r\\n                              x\\r\\n                              (+ (fib (- x 1))\\r\\n                                 (fib (- x 2)))))))\\r\\n(time (fib 35))" "(time (fib 35))" "(time (fib 36))" "(def get-visible-fields \\n  (memoize (fn [cls]\\r\\n  \\"Retrieve all fields that are visible to any instances of class cls.\\r\\nMore specifically, all fields declared directly in cls, and all public/protected fields found in its ancestor classes.\\"\\r\\n  (let\\r\\n    ; All fields declared directly in cls\\r\\n    [declFields (-> cls .getDeclaredFields)\\r\\n     ; All fields declared in the ancestor classes of cls\\r\\n     ancestorFields (if (\= java.lang.Object cls)\\r\\n                      []\\r\\n                      (get-visible-fields (-> cls .getSuperclass)))\\r\\n     ; Remove all private and hidden fields from ancestorFields\\r\\n     filteredAncestors (filter (fn [aField]\\r\\n                                 (and\\r\\n                                   (not (Modifier/isPrivate (-> aField .getModifiers)))\\n                                   (not (Modifier/isNative (-> aField .getModifiers)))\\r\\n                                   (every? (fn [dField] (not\= (-> dField .getName) (-> aField .getName)))\\r\\n                                         declFields)))\\r\\n                               ancestorFields)]\\r\\n    (concat declFields filteredAncestors)))))" "(get-visible-methods-mem (.getClass (new Object)))" "(get-visible-methods (.getClass (new Object)))" "(time (get-visible-methods (.getClass (new Test))))" "(import scratchpad.Test)" "(time (get-visible-methods (.getClass (new Test))))" "(import javax.swing.JPanel)" "(time (get-visible-methods (.getClass (new JPanel))))" ";; Switching to inspector-jay.core namespace" "(inspect (new Object))" "(inspect (new JPanel))" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod get-child \:default [node index]\\r\\n  (if (< index (-> node .countMethods))\\r\\n    (let\\r\\n      [meth (nth (-> node .getMethods) index)]\\n      (method-node meth (-> node .getValue)))\\r\\n    (let\\r\\n      [field-index (- index (-> node .countMethods))\\r\\n       field (nth (-> node .getFields) field-index)]\\n      (field-node field (-> node .getValue)))))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new JPanel))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value.\\nIf the call produces an exception, it is caught and returned as the return value instead.\\r\\nTODO\: Only supports methods with no parameters, for now..\\"\\r\\n  (try\\n    (-> method (.invoke object nil))\\n    (catch Exception e (e)))\\n(clojure.core/ns inspector-jay.core)" "(defn invoke-method\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value.\\nIf the call produces an exception, it is caught and returned as the return value instead.\\r\\nTODO\: Only supports methods with no parameters, for now..\\"\\r\\n  (try\\n    (-> method (.invoke object nil))\\n    (catch Exception e (e))))" "(inspect (new JPanel))" ";; Switching to inspector-jay.core namespace" "(inspect (new JPanel))" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value.\\nIf the call produces an exception, it is caught and returned as the return value instead.\\r\\nTODO\: Only supports methods with no parameters, for now..\\"\\r\\n  (try\\n    (-> method (.invoke object nil))\\n    (catch Exception e (e))))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value.\\nIf the call produces an exception, it is caught and returned as the return value instead.\\r\\nTODO\: Only supports methods with no parameters, for now..\\"\\r\\n  (try\\n    (-> method (.invoke object nil))\\n    (catch Exception e (\\"hello\\"))))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value.\\nIf the call produces an exception, it is caught and returned as the return value instead.\\r\\nTODO\: Only supports methods with no parameters, for now..\\"\\r\\n  (try\\n    (-> method (.invoke object nil))\\n    (catch Exception e \\"hello\\")))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value.\\nIf the call produces an exception, it is caught and returned as the return value instead.\\r\\nTODO\: Only supports methods with no parameters, for now..\\"\\r\\n  (try\\n    (-> method (.invoke object nil))\\n    (catch Exception e e)))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value.\\nIf the call produces an exception, it is caught and returned as the return value instead.\\r\\nTODO\: Only supports methods with no parameters, for now..\\"\\n  (-> method (.invoke object nil)))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value.\\nIf the call produces an exception, it is caught and returned as the return value instead.\\r\\nTODO\: Only supports methods with no parameters, for now..\\"\\n;  (-> method (.invoke object nil)))\\r\\n  (try\\n    (-> method (.invoke object nil))\\n    (catch InvocationTargetException e e)))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(ns inspector-jay.tree-node\\n  \\"Defines the data structure of a tree node\\"\\r\\n  {\:author \\"Tim Molderez\\"}\\n  (\:import\\n     [java.lang.reflect Modifier]\\n     [java.lang.reflect InvocationTargetException]))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value.\\nIf the call produces an exception, it is caught and returned as the return value instead.\\r\\nTODO\: Only supports methods with no parameters, for now..\\"\\n;  (-> method (.invoke object nil)))\\r\\n  (try\\n    (-> method (.invoke object nil))\\n    (catch InvocationTargetException e e)))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value.\\nIf the call produces an exception, it is caught and returned as the return value instead.\\r\\nTODO\: Only supports methods with no parameters, for now..\\"\\n;  (-> method (.invoke object nil)))\\r\\n  (try\\n    (-> method (.invoke object nil))\\n    (catch InvocationTargetException e (-> e .getCause))))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defn invoke-method\\r\\n  [method object]\\r\\n  \\"Call a method on an object via reflection, and return its return value.\\nIf the call produces an exception, it is caught and returned as the return value instead.\\r\\nTODO\: Only supports methods with no parameters, for now..\\"\\n;  (-> method (.invoke object nil)))\\r\\n  (try\\n    (-> method (.invoke object nil))\\n    (catch Exception e (-> e .getCause))))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" "(e)" "(count nil)" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" "(println nil)" "(clojure.core/ns inspector-jay.tree-node)\\n(deftype TreeNode\\r\\n  [data]\\r\\n  ITreeNode\\n  (getValue [this] \\n    (force (data \:value)))\\n  (hasValue [this] \\n    (and\\n      (contains? data \:value))\\n      (not\= (data \:value) nil))\\n  (getMethod [this]\\n    (data \:method))\\n  (getField [this]\\n    (data \:field))\\n  (getMethods [this]\\n    (println this)\\n    (if (-> this .hasValue)\\n      (get-visible-methods (-> this .getValue .getClass))\\n      nil))\\n  (getFields [this]\\n    (if (-> this .hasValue)\\n      (get-visible-fields (-> this .getValue .getClass))\\n      nil))\\n  (getKind [this]\\n    (cond\\n      (sequential? (data \:value)) \:sequence\\n      (contains? data \:method) \:method\\r\\n      (contains? data \:field) \:field\\n      \:else \:object))\\n  (countMethods [this]\\n    (count (-> this .getMethods)))\\n  (countFields [this]\\n    (count (-> this .getFields))))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(deftype TreeNode\\r\\n  [data]\\r\\n  ITreeNode\\n  (getValue [this] \\n    (force (data \:value)))\\n  (hasValue [this] \\n    (and\\n      (contains? data \:value))\\n      (not\= (data \:value) nil))\\n  (getMethod [this]\\n    (data \:method))\\n  (getField [this]\\n    (data \:field))\\n  (getMethods [this]\\n    (println this)\\n    (if (-> this .hasValue)\\n      (get-visible-methods (-> this .getValue .getClass))\\n      nil))\\n  (getFields [this]\\n    (if (-> this .hasValue)\\n      (get-visible-fields (-> this .getValue .getClass))\\n      nil))\\n  (getKind [this]\\n    (cond\\n      (sequential? (data \:value)) \:sequence\\n      (contains? data \:method) \:method\\r\\n      (contains? data \:field) \:field\\n      \:else \:object))\\n  (countMethods [this]\\n    (count (-> this .getMethods)))\\n  (countFields [this]\\n    (count (-> this .getFields))))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" "(delay 5)" "(realized? 5)" "(realized? (delay 5))" "(def bla (delay nil))" "bla" "(force bla)" "bla" "(clojure.core/ns inspector-jay.tree-node)\\n(deftype TreeNode\\r\\n  [data]\\r\\n  ITreeNode\\n  (getValue [this] \\n    (force (data \:value)))\\n  (hasValue [this] \\n    (and\\n      (contains? data \:value))\\n      (not\= (data \:value) nil))\\n  (getMethod [this]\\n    (data \:method))\\n  (getField [this]\\n    (data \:field))\\n  (getMethods [this]\\n    (if (not\= (-> this .getValue) nil)\\n      (get-visible-methods (-> this .getValue .getClass))\\n      nil))\\n  (getFields [this]\\n    (if (not\= (-> this .getValue) nil)\\n      (get-visible-fields (-> this .getValue .getClass))\\n      nil))\\n  (getKind [this]\\n    (cond\\n      (sequential? (data \:value)) \:sequence\\n      (contains? data \:method) \:method\\r\\n      (contains? data \:field) \:field\\n      \:else \:object))\\n  (countMethods [this]\\n    (count (-> this .getMethods)))\\n  (countFields [this]\\n    (count (-> this .getFields))))\\n(clojure.core/ns inspector-jay.core)" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(definterface ITreeNode\\n  \\"Container type for tree nodes\\"\\n  (getValue [])\\n  (hasValue [])\\n  (getMethod [])\\n  (getField [])\\n  (getMethods [])\\r\\n  (getFields [])\\n  (getKind[])\\n  (countMethods [])\\n  (countFields []))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defprotocol ITreeNode\\n  \\"Container type for tree nodes\\"\\n  (getValue [])\\n  (hasValue [])\\n  (getMethod [])\\n  (getField [])\\n  (getMethods [])\\r\\n  (getFields [])\\n  (getKind[])\\n  (countMethods [])\\n  (countFields []))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defprotocol ITreeNode\\n  \\"Container type for tree nodes\\"\\n  (getValue [this])\\n  (hasValue [this])\\n  (getMethod [this])\\n  (getField [this])\\n  (getMethods [this])\\r\\n  (getFields [this])\\n  (getKind[this])\\n  (countMethods [this])\\n  (countFields [this]))\\n(clojure.core/ns inspector-jay.core)" ";; Switching to inspector-jay.tree-node namespace" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string-verbose \:method [node]\\n  (join [\\n         (-> node .getMethod .toString)\\n         \\"\\\\n\\\\n\\"\\n         (if (-> node .hasValue)\\n           (-> node .getValue))\\n         \\n         ]))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string-verbose \:method [node]\\n  (join [\\n         (-> node .getMethod .toString)\\n         \\"\\\\n\\\\n\\"\\n         (if (-> node .hasValue)\\n           (-> node .getValue)\\n           \\"nope\\")\\n         \\n         ]))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string-verbose \:method [node]\\n  (join [\\n         (-> node .getMethod .toString)\\n         \\"\\\\n\\\\n\\"\\n         (if (-> node .hasValue)\\n           \\"fdsfsd\\"\\n           \\"nope\\")\\n         \\n         ]))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string-verbose \:method [node]\\n  (join [\\n         (-> node .getMethod .toString)\\n         \\"\\\\n\\\\n\\"\\n         (if (realized? (node \:value))\\n           (-> node .getValue)\\n           \\"nope\\")\\n         \\n         ]))\\n(clojure.core/ns inspector-jay.core)" "\=> (inspect (new Test))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string-verbose \:method [node]\\n  (join [\\n         (-> node .getMethod .toString)\\n         \\"\\\\n\\\\n\\"\\n         (if (realized? (.getData node))\\n           (-> node .getValue)\\n           \\"nope\\")\\n         \\n         ]))\\n(clojure.core/ns inspector-jay.core)" "\=> (inspect (new Test))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string-verbose \:method [node]\\n  (join [\\n         (-> node .getMethod .toString)\\n         \\"\\\\n\\\\n\\"\\n         (if (realized? (.data node))\\n           (-> node .getValue)\\n           \\"nope\\")\\n         \\n         ]))\\n(clojure.core/ns inspector-jay.core)" "\=> (inspect (new Test))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string-verbose \:method [node]\\n  (join [\\n         (-> node .getMethod .toString)\\n         \\"\\\\n\\\\n\\"\\n         (if (realized? ((.data node) \:value))\\n           (-> node .getValue)\\n           \\"nope\\")\\n         \\n         ]))\\n(clojure.core/ns inspector-jay.core)" "\=> (inspect (new Test))" "(clojure.core/ns inspector-jay.tree-node)\\n(defprotocol ITreeNode\\n  \\"Container type for tree nodes in the object inspector.\\nA tree node represents a Java object; it may be the return value of a method call, or the value of a field.\\"\\n  (getValue [this])\\n  (hasValue [this])\\n  (isValueRealized [this])\\n  (getMethod [this])\\n  (getField [this])\\n  (getMethods [this])\\r\\n  (getFields [this])\\n  (getKind[this])\\n  (countMethods [this])\\n  (countFields [this]))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defprotocol ITreeNode\\n  \\"Container type for tree nodes in the object inspector.\\nA tree node represents a Java object; it may be the return value of a method call, or the value of a field.\\"\\n  (getValue [this]\\n    \\"Retrieve the Java object contained by this node. In case the object is not available yet, it will be made available now. \\n(This typically is the case if the object is the return value of a method that has not been invoked yet.)\\")\\n  (hasValue [this])\\n  (isValueRealized [this])\\n  (getMethod [this])\\n  (getField [this])\\n  (getMethods [this])\\r\\n  (getFields [this])\\n  (getKind[this])\\n  (countMethods [this])\\n  (countFields [this]))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn method-node ^ITreeNode\\n  [method receiver]\\n  \\"Create a method node, given the method and its receiver object.\\n   The object contained by this node is the return value of invoking the method.\\"\\n  (if \\n    (and\\n      (not (Modifier/isNative (-> method .getModifiers)))\\n      (not\= \\"void\\" (-> method .getReturnType .getSimpleName)) \\n      (\= 0 (count (-> method .getParameterTypes))))\\n    (let []\\n      (-> method (.setAccessible true)) ; Enable access to private methods\\n      (new TreeNode {\:method method \:value (delay (invoke-method method receiver))}))\\n    (new TreeNode {\:method method \:value nil})))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defprotocol ITreeNode\\n  \\"Container type for tree nodes in the object inspector.\\n   A tree node contains a Java object; this object may be the return value of a method call, or the value of a field.\\"\\n  (getValue [this]\\n    \\"Retrieve the Java object contained by this node. In case the object is not available yet, it will be made available now. \\n     (This typically is the case if the object is the return value of a method that has not been invoked yet.)\\")\\n  (hasValue [this]\\n    \\"Does this node contain a non-nil object? \\n     (If the object is not available yet, we assume it has a non-nil value..)\\")\\n  (isValueAvailable [this]\\n    \\"Is the object contained by this node available?\\")\\n  (getMethod [this]\\n    \\"Retrieve the method that produces the node's value as its return value. (may be nil)\\")\\n  (getField [this]\\n    \\"Retrieve the field associated with this node's value. (may be nil)\\")\\n  (getMethods [this]\\n    \\"Retrieve the methods in the node value's class. (if this value is nil, nil is returned)\\")\\r\\n  (getFields [this]\\n    \\"Retrieve the fields in the node value's class. (if this value is nil, nil is returned)\\")\\n  (countMethods [this]\\n    \\"Retrieve how many method are in the node value's class.\\")\\r\\n  (countFields [this]\\n    \\"Retrieve how many fields are in the node value's class.\\")\\n  (getKind[this]\\n    \\"Retrieve a keyword that represents this node\:\\n     \:object   This is a generic object node.\\n     \:method   The object contained in this node is the return value of a method call.\\n     \:field    The object contained in this node is the value of a field.\\n     \:sequence The object contained in this node is a Clojure sequence, or a Java collection.\\"))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn method-node ^ITreeNode\\n  [method receiver]\\n  \\"Create a method node, given the method and its receiver object.\\n   The object contained by this node is the return value of invoking the method.\\"\\n  (if \\n    (and\\n      (not (Modifier/isNative (-> method .getModifiers)))\\n      (not\= \\"void\\" (-> method .getReturnType .getSimpleName)) \\n      (\= 0 (count (-> method .getParameterTypes))))\\n    (let []\\n      (-> method (.setAccessible true)) ; Enable access to private methods\\n      (new TreeNode {\:method method \:value (delay (invoke-method method receiver))}))\\n    (new TreeNode {\:method method \:value nil})))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn method-node ^TreeNode\\n  [method receiver]\\n  \\"Create a method node, given the method and its receiver object.\\n   The object contained by this node is the return value of invoking the method.\\"\\n  (if \\n    (and\\n      (not (Modifier/isNative (-> method .getModifiers)))\\n      (not\= \\"void\\" (-> method .getReturnType .getSimpleName)) \\n      (\= 0 (count (-> method .getParameterTypes))))\\n    (let []\\n      (-> method (.setAccessible true)) ; Enable access to private methods\\n      (new TreeNode {\:method method \:value (delay (invoke-method method receiver))}))\\n    (new TreeNode {\:method method \:value nil})))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(ns inspector-jay.tree-node\\n  \\"Defines the data structure of a tree node\\"\\r\\n  {\:author \\"Tim Molderez\\"}\\n  (\:import\\n     [java.lang.reflect Modifier Method]\\n     [java.lang.reflect InvocationTargetException]))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn object-node ^TreeNode\\r\\n  [^Object object]\\n  \\"Create a new generic object node.\\"\\n  (new TreeNode {\:value object}))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defn method-node ^TreeNode\\n  [^Method method ^Object receiver]\\n  \\"Create a method node, given the method and its receiver object.\\n   The object contained by this node is the return value of invoking the method.\\"\\n  (if \\n    (and\\n      (not (Modifier/isNative (-> method .getModifiers)))\\n      (not\= \\"void\\" (-> method .getReturnType .getSimpleName)) \\n      (\= 0 (count (-> method .getParameterTypes))))\\n    (let []\\n      (-> method (.setAccessible true)) ; Enable access to private methods\\n      (new TreeNode {\:method method \:value (delay (invoke-method method receiver))}))\\n    (new TreeNode {\:method method \:value nil})))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(ns inspector-jay.tree-node\\n  \\"Defines the data structure of a tree node\\"\\r\\n  {\:author \\"Tim Molderez\\"}\\n  (\:import\\n     [java.lang.reflect Modifier Method Field]\\n     [java.lang.reflect InvocationTargetException]))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(ns inspector-jay.tree-node\\n  \\"Defines the data structure of a tree node\\"\\r\\n  {\:author \\"Tim Molderez\\"}\\n  (\:import\\n     [java.lang.reflect Modifier Method Field InvocationTargetException]\\n     [clojure.lang Delay]))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(deftype TreeNode\\r\\n  [data]\\r\\n  ITreeNode\\n  (getValue [this] \\n    (force (data \:value)))\\n  (hasValue [this] \\n    (and\\n      (contains? data \:value))\\n      (not\= (data \:value) nil))\\n  (isValueAvailable [this]\\n    (if (instance? Delay (data \:value))\\n      (realized? (data \:value))\\n      true))\\n  (getMethod [this]\\n    (data \:method))\\n  (getField [this]\\n    (data \:field))\\n  (getMethods [this]\\n    (if (not\= (-> this .getValue) nil)\\n      (get-visible-methods (-> this .getValue .getClass))\\n      nil))\\n  (getFields [this]\\n    (if (not\= (-> this .getValue) nil)\\n      (get-visible-fields (-> this .getValue .getClass))\\n      nil))\\n  (countMethods [this]\\r\\n    (count (-> this .getMethods)))\\r\\n  (countFields [this]\\r\\n    (count (-> this .getFields)))\\n  (getKind [this]\\n    (cond\\n      (sequential? (data \:value)) \:sequence\\n      (contains? data \:method) \:method\\r\\n      (contains? data \:field) \:field\\n      \:else \:object)))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-node)\\n(defprotocol ITreeNode\\n  \\"Container type for tree nodes in the object inspector.\\n   A tree node contains a Java object; this object may be the return value of a method call, or the value of a field.\\"\\n  (getValue [this]\\n    \\"Retrieve the Java object contained by this node. In case the object is not available yet, it will be made available now. \\n     (This typically is the case if the object is the return value of a method that has not been invoked yet.)\\")\\n  (hasValue [this]\\n    \\"Does this node contain a non-nil object? \\n     (If the object is not available yet, we assume it has a non-nil value..)\\")\\n  (isValueAvailable [this]\\n    \\"Is the object contained by this node available?\\")\\n  (getMethod [this]\\n    \\"Retrieve the method that produces the node's value as its return value. (may be nil)\\")\\n  (getField [this]\\n    \\"Retrieve the field associated with this node's value. (may be nil)\\")\\n  (getMethods [this]\\n    \\"Retrieve the methods in the node value's class. (if this value is nil, nil is returned)\\")\\r\\n  (getFields [this]\\n    \\"Retrieve the fields in the node value's class. (if this value is nil, nil is returned)\\")\\n  (countMethods [this]\\n    \\"Retrieve how many method are in the node value's class.\\")\\r\\n  (countFields [this]\\n    \\"Retrieve how many fields are in the node value's class.\\")\\n  (getKind[this]\\n    \\"Retrieve a keyword that represents this node\:\\n     \:object   This is a generic object node.\\n     \:method   The object contained in this node is the return value of a method call.\\n     \:field    The object contained in this node is the value of a field.\\n     \:sequence The object contained in this node is a Clojure sequence, or a Java collection.\\"))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string-verbose \:method [node]\\n  (join [\\n         (-> node .getMethod .toString)\\n         \\"\\\\n\\\\n\\"\\n         (if (-> node .isValueAvailable)\\n           (-> node .getValue)\\n           \\"(Open this method node to invoke it and inspect its return value..)\\")\\n         \\n         ]))\\n(clojure.core/ns inspector-jay.core)" ";; Switching to inspector-jay.core namespace" "\=> (inspect (new Test))" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string-verbose \:method [node]\\n  (join [\\n         (-> node .getMethod .toString)\\n         \\"\\\\n\\\\n\\"\\n         (if (-> node .isValueAvailable)\\n           (-> node .getValue))\\n         ]))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string-verbose \:method [node]\\n  (join [\\n         (-> node .getMethod .toString)      \\n         (if (-> node .isValueAvailable)\\n           (join\\n             [\\"\\\\n\\\\n\\"\\n              (-> node .getValue)]))\\n         ]))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" "(println *file*)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn bla []\\n  (println *file*))\\n(clojure.core/ns inspector-jay.core)" "(bla)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn bla []\\n  (println *file*))\\n(clojure.core/ns inspector-jay.core)" ";; Switching to inspector-jay.tree-ui namespace" "(bla)" "(println (pr-str &form))" "(defmacro ? [x]\\r\\n(let [line (\:line (meta &form))\\r\\nfile *file*]\\r\\n`(let [x\# ~x]\\r\\n(println (pr-str '~x) \\"is\\" (pr-str x\#)\\r\\n(str \\"; (\\" ~file \\"\:\\" ~line \\")\\"))\\r\\nx\#)))" "(let [x 10]\\r\\n(+ 5 (? x)))" "(let [x 10]\\r\\n   (+ 5 (? x)))" "(clojure.core/ns inspector-jay.core)\\n(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\n  Note that the object itself is also returned such that you can use this function anywhere without affecting the program's behaviour.\\"\\r\\n\\t(let [f (frame \:title (str \\"Object inspector \: \\" (.toString object) \\"(\\" ~file \\"\:\\" ~line \\")\\") \\n                \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (config\! f \:content split-pane)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))\\n(clojure.core/ns inspector-jay.tree-ui)" "(clojure.core/ns inspector-jay.core)\\n(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\n  Note that the object itself is also returned such that you can use this function anywhere without affecting the program's behaviour.\\"\\r\\n\\t(let [f (frame \:title (str \\"Object inspector \: \\" (.toString object) \\"(\\" *file* \\"\:\\" ~line \\")\\") \\n                \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (config\! f \:content split-pane)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))\\n(clojure.core/ns inspector-jay.tree-ui)" "(clojure.core/ns inspector-jay.core)\\n(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\n  Note that the object itself is also returned such that you can use this function anywhere without affecting the program's behaviour.\\"\\r\\n\\t(let [f (frame \:title (str \\"Object inspector \: \\" (.toString object) \\"(\\" *file* \\"\:\\" *line* \\")\\") \\n                \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (config\! f \:content split-pane)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))\\n(clojure.core/ns inspector-jay.tree-ui)" "(clojure.core/ns inspector-jay.core)\\n(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\n  Note that the object itself is also returned such that you can use this function anywhere without affecting the program's behaviour.\\"\\r\\n\\t(let [f (frame \:title (str \\"Object inspector \: \\" (.toString object)) \\n                \:minimum-size [(options \:width) \:by (options \:height)])\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (config\! f \:content split-pane)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))\\n(clojure.core/ns inspector-jay.tree-ui)" "(println (pr-str &form))" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" "(def options\\n  {\:width 800,\\n   \:height 600\\n   \:font (font \:name \:sans-serif \:style \#{\:plain})})" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string \:method [node]\\r\\n  (str\\n    (-> node .getMethod .getName)\\r\\n    \\"(\\"\\r\\n    (join (interpose \\", \\" (map (memfn getSimpleName) (-> node .getMethod .getParameterTypes))))\\r\\n    \\") \: \\"\\r\\n    (-> node .getMethod .getReturnType .getSimpleName)))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-renderer ^DefaultTreeCellRenderer\\n  []\\r\\n  \\"Returns a cell renderer which defines what each tree node should look like\\"\\r\\n  (proxy [DefaultTreeCellRenderer] []\\r\\n    (getTreeCellRendererComponent [tree value selected expanded leaf row hasFocus]\\r\\n      (proxy-super getTreeCellRendererComponent tree value selected expanded leaf row hasFocus)\\r\\n      (-> this (.setText (to-string value)))\\r\\n      (-> this (.setIcon (get-icon value)))\\r\\n      this)))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string \:field [node]\\r\\n  (str\\n    (-> node .getField .getName)\\r\\n    \\" \: \\"\\r\\n    (-> node .getValue)))\\n(clojure.core/ns inspector-jay.core)" "(inspect [1 2 3])" "{\:a 1 \:b 2}" "(inspect {\:a 1 \:b 2})" "(def bla {\:a 1 \:b 2})" "(coll? bla)" "(count bla)" "(first bla)" "(nth bla)" "(nth bla 0)" "(keys bla)" "(nth (keys bla) 0)" "(bla (nth (keys bla) 0))" "(use '(clojure.inspect))" "(inspect-tree 5)" "(use '(clojure.inspector inspect-tree))" "(use '(clojure.inspector))" "(inspect-tree bla)" "(use '(clojure.inspector inspect-tree))" "(use '(clojure.inspector))" "(require '(clojure.inspector))" "(clojure.inspector/inspect-tree)" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use\\n    [clojure.stacktrace]\\n    [clojure.string \:only [split join]]\\n    [seesaw\\n     [core]\\n     [font]]\\n    [inspector-jay\\n     [tree-node \:only [object-node]]\\n     [tree-model]\\n     [tree-ui]])\\n  (\:use [clojure.inspector])\\n  (\:import\\n    [scratchpad Test]\\n    [javax.swing JPanel]))" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use\\n    [clojure.stacktrace]\\n    [clojure.string \:only [split join]]\\n    [seesaw\\n     [core]\\n     [font]]\\n    [inspector-jay\\n     [tree-node \:only [object-node]]\\n     [tree-model]\\n     [tree-ui]])\\n  (\:use [clojure.inspector \:only [inspect-tree]])\\n  (\:import\\n    [scratchpad Test]\\n    [javax.swing JPanel]))" ";; Switching to inspector-jay.core namespace" "(inspect-tree {\:a 1 \:b 21})" "(clojure.core/ns inspector-jay.tree-node)\\n(deftype TreeNode\\r\\n  [data]\\r\\n  ITreeNode\\n  (getValue [this] \\n    (force (data \:value)))\\n  (hasValue [this] \\n    (and\\n      (contains? data \:value))\\n      (not\= (data \:value) nil))\\n  (isValueAvailable [this]\\n    (if (instance? Delay (data \:value))\\n      (realized? (data \:value))\\n      true))\\n  (getMethod [this]\\n    (data \:method))\\n  (getField [this]\\n    (data \:field))\\n  (getMethods [this]\\n    (if (not\= (-> this .getValue) nil)\\n      (get-visible-methods (-> this .getValue .getClass))\\n      nil))\\n  (getFields [this]\\n    (if (not\= (-> this .getValue) nil)\\n      (get-visible-fields (-> this .getValue .getClass))\\n      nil))\\n  (countMethods [this]\\r\\n    (count (-> this .getMethods)))\\r\\n  (countFields [this]\\r\\n    (count (-> this .getFields)))\\n  (getKind [this]\\n    (cond\\n      (instance? java.util.Map (data \:value)) \:map\\n      (sequential? (data \:value)) \:sequence\\n      (contains? data \:method) \:method\\r\\n      (contains? data \:field) \:field\\n      \:else \:object)))\\n(clojure.core/ns inspector-jay.core)" "(count bla)" "bla" "(def bla {\:b 4 \:f 6})" "(def blaa {\:b 4 \:f 6})" "(count blaa)" "(def blaa {\:b 4 \:f 6 \:hg 7})" "(count blaa)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod get-child \:map [node index]\\r\\n  (object-node (nth (seq (-> node .getValue)) index)))\\n(clojure.core/ns inspector-jay.core)" ";; Switching to inspector-jay.core namespace" "(inspect {\:a 543 \:b 55})" "(import java.swing.JPanel)" "(import javax.swing.JPanel)" "(inspect (new JPanel))" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" "(clojure.core/ns inspector-jay.tree-model)\\n(defn node-kind [node]\\n  \\"Dispatch function for the multimethods in this tree model. Determines what kind of node we're dealing with.\\"\\n  (let [cls (-> node .getValueClass)]\\n    (cond\\n      (instance? clojure.lang.Sequential cls) \:sequence\\n      (instance? java.util.Map cls) \:map\\n      \:else (-> node .getKind))))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-model)\\n;      (sequential? (data \:value)) \:sequence\\n(defn node-kind [node]\\n  \\"Dispatch function for the multimethods in this tree model. Determines what kind of node we're dealing with.\\"\\n  (let [cls (-> node .getValueClass)]\\n    (cond\\n      (instance? clojure.lang.Sequential cls) \:sequence\\n      (instance? java.util.Map cls) \:map\\n      \:else (-> node .getKind))))\\n\\n(defmulti is-leaf\\n  \\"Is this tree node a leaf?\\"\\n  (fn [node] (node-kind node)))\\r\\n(defmulti get-child\\n  \\"Get the child of a node at a certain index\\"\\n  (fn [node index] (node-kind node)))\\r\\n(defmulti get-child-count\\n  \\"Get the number of children of a node\\"\\n  (fn [node] (node-kind node)))\\n(clojure.core/ns inspector-jay.core)" ";; Switching to inspector-jay.core namespace" "(inspect [1 2])" "(clojure.core/ns inspector-jay.tree-model)\\n(defn node-kind [node]\\n  \\"Dispatch function for the multimethods in this tree model. Determines what kind of node we're dealing with.\\"\\n  (let [cls (-> node .getValueClass)]\\n    (cond\\n      (-> clojure.lang.Sequential (.isAssignableFrom cls)) \:sequence\\n      (-> java.util.Map (.isAssignableFrom cls)) \:map\\n      \:else (-> node .getKind))))\\n(clojure.core/ns inspector-jay.core)" "(inspect [1 2])" "(inspect {\:a 4324})" "(inspect (new Test))" "(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\n  Note that the object itself is also returned such that you can use this function anywhere without affecting the program's behaviour.\\"\\r\\n\\t(let [f (frame \:title (str \\"Object inspector \: \\" (.toString object)) \\n                \:minimum-size [(options \:width) \:by (options \:height)]\\n                \:on-close \:dispose)\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (config\! f \:content split-pane)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))" "(inspect (new Test))" "(+ 1 1)" "(-> [1 2 3] .size)" "(type [1 23])" "(to-array [1 2 3])" "(type (to-array [1 2 3]))" "(count (to-array [1 2 3]))" "(nth (to-array [1 2 3]) 0)" "(import java.lang.Vector)" "(import java.util.Vector)" "(new Vector)" "(count (new Vector))" "(def blagh (new Vector))" "(.add blagh 5)" "blagh" "(first blagh)" "(nth blagh 0)" "(clojure.core/ns inspector-jay.tree-model)\\n(defn node-kind [node]\\n  \\"Dispatch function for the multimethods in this tree model. Determines what kind of node we're dealing with.\\"\\n  (let [cls (-> node .getValueClass)]\\n    (cond\\n      (-> clojure.lang.Sequential (.isAssignableFrom cls)) \:sequence\\n      (-> clojure.lang.Sequential (.isAssignableFrom cls)) \:sequence\\n      (-> java.util.RandomAccess (.isAssignableFrom cls)) \:sequence\\n      (-> cls .isArray) \:sequence\\n      (-> java.util.Map (.isAssignableFrom cls)) \:map\\n      \:else (-> node .getKind))))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(clojure.core/ns inspector-jay.tree-model)\\n(defn dispatch-node-kind [node]\\n  \\"Determines what kind of node we're dealing with.\\"\\n  (let [cls (-> node .getValueClass)]\\n    (cond\\n      ; A \:sequence is anything that supports the nth function..\\n      (-> clojure.lang.Sequential (.isAssignableFrom cls)) \:sequence\\n      (-> java.util.RandomAccess (.isAssignableFrom cls)) \:sequence\\n      (-> cls .isArray) \:sequence\\n      ; All collections support the count and seq functions.. \\n      (-> java.util.Collection (.isAssignableFrom cls)) \:collection\\n      \:else \:default)))\\n(clojure.core/ns inspector-jay.core)" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" ";; Switching to inspector-jay.core namespace" "(inspect (new Test))" "(javadoc JPanel)" "(use 'clojure.java.javadoc)" "(javadoc JPanel)" "(doc doc)" "(use 'clojure.repl.doc)" "(use 'clojure.repl)" "(use 'clojure.repl \:only [doc])" ";; Switching to inspector-jay.core namespace" "(use 'clojure.repl \:only [doc])" "(use 'clojure.repl)" "(doc doc)" "(doc (type doc))" "(doc 6)" "(doc max)" "(inspect max)" "(use 'clojure.java.javadoc)" "(javadoc-url Test)" "(javadoc Test)" "(javadoc Object)" "(use ' clojure.contrib.repl-utils.javadoc)" "(defn- bindKeys ^void\\r\\n  [^JFrame f]\\r\\n  (let\\r\\n    [escKey (KeyEvent/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\r\\n    (listen f \:key))\\r\\n  )" "(defn- bindKeys ^void\\r\\n  [^JFrame f]\\r\\n  (let\\r\\n    [escKey 0]\\r\\n    (listen f \:key))\\r\\n  )" "(defn- bindKeys ^void\\r\\n  [^JFrame f]\\r\\n  (let\\r\\n    [escKey (KeyEvent/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\r\\n    (listen f \:key))\\r\\n  )" "(defn- bindKeys ^void\\r\\n  [^JFrame f]\\r\\n  (let\\r\\n    [escKey (KeyEvent/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\r\\n    5)\\r\\n  )" "(def options\\n  {\:width 800,\\n   \:height 600\\n   \:font (font \:name \:sans-serif \:style \#{\:plain})})" "(defn- bindKeys\\r\\n  [^JFrame f]\\r\\n  (let\\r\\n    [escKey (KeyEvent/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\r\\n    5)\\r\\n  )" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use\\n    [seesaw\\n     [core]\\n     [font]]\\n    [inspector-jay\\n     [tree-node \:only [object-node]]\\n     [tree-model]\\n     [tree-ui]])\\n  (\:import\\n    [java.swing KeyStroke]\\n    [java.awt.event KeyEvent]))" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use\\n    [seesaw\\n     [core]\\n     [font]]\\n    [inspector-jay\\n     [tree-node \:only [object-node]]\\n     [tree-model]\\n     [tree-ui]])\\n  (\:import\\n    [javax.swing KeyStroke]\\n    [java.awt.event KeyEvent]))" "(defn- bindKeys\\r\\n  [^JFrame f]\\r\\n  (let\\r\\n    [escKey (KeyEvent/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\r\\n    5)\\r\\n  )" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use\\n    [seesaw\\n     [core]\\n     [font]]\\n    [inspector-jay\\n     [tree-node \:only [object-node]]\\n     [tree-model]\\n     [tree-ui]])\\n  (\:import\\n    [javax.swing KeyStroke JFrame]\\n    [java.awt.event KeyEvent]))" "(defn- bindKeys\\r\\n  [^JFrame f]\\r\\n  (let\\r\\n    [escKey (KeyEvent/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\r\\n    5)\\r\\n  )" "(defn- bindKeys\\r\\n  [^JFrame f]\\r\\n  (let\\r\\n    [escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\r\\n    5)\\r\\n  )" "(defn- bindKeys\\r\\n  [^JFrame f]\\r\\n  (let\\r\\n    [escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\n    [f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)]\\r\\n    (listen f \:keypressed \\n      (fn [event]\\n        5)))\\r\\n  )" "(defn- bindKeys\\r\\n  [^JFrame f]\\r\\n  (let\\r\\n    [escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\n    [fKey (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)]\\r\\n    (listen f \:keypressed \\n      (fn [event]\\n        5)))\\r\\n  )" "(defn- bindKeys\\r\\n  [^JFrame f]\\r\\n  (let\\r\\n    [escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)\\n     fKey (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)]\\r\\n    (listen f \:keypressed \\n      (fn [event]\\n        5)))\\r\\n  )" "(defn- bindKeys\\r\\n  [^JFrame f]\\r\\n  (let\\r\\n    [escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)\\n     f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)]\\r\\n    (listen f \:keypressed \\n      (fn [event]\\n        5)))\\r\\n  )" "(defn- bindKeys\\r\\n  [^JFrame f]\\r\\n  (let\\r\\n    [escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)\\n     f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)]\\r\\n    (listen f \:keypressed \\n      (fn [event]\\n        (println (-> event .getKeyCode)))))\\r\\n  )" "(inspect 5)" "(defn- bindKeys\\r\\n  [^JFrame f]\\r\\n  (let\\r\\n    [escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)\\n     f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)]\\r\\n    (listen f \:key-pressed \\n      (fn [event]\\n        (println (-> event .getKeyCode)))))\\r\\n  )" "(inspect 5)" "(defn- bindKeys\\r\\n  [^JFrame f]\\r\\n  (let\\r\\n    [escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)\\n     f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)]\\r\\n    (listen f \:key-pressed \\n      (fn [event]\\n        (println \\"fdsfjds\\"))))\\r\\n  )" "(inspect 5)" "(defn- bindKeys\\r\\n  [component]\\r\\n  (let\\r\\n    [escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)\\n     f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)]\\r\\n    (listen component \:key-pressed \\n      (fn [event]\\n        (println \\"fdsfjds\\"))))\\r\\n  )" "(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\n  Note that the object itself is also returned such that you can use this function anywhere without affecting the program's behaviour.\\"\\r\\n\\t(let [f (frame \:title (str \\"Object inspector \: \\" (.toString object)) \\n                \:minimum-size [(options \:width) \:by (options \:height)]\\n                \:on-close \:dispose)\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (bindKeys obj-tree)\\n   (config\! f \:content split-pane)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))" "(inspect 5)" "(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\n  Note that the object itself is also returned such that you can use this function anywhere without affecting the program's behaviour.\\"\\r\\n\\t(let [f (frame \:title (str \\"Object inspector \: \\" (.toString object)) \\n                \:minimum-size [(options \:width) \:by (options \:height)]\\n                \:on-close \:dispose)\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (bindKeys (-> f .getRootPane))\\n   (config\! f \:content split-pane)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))" "(inspect 5)" "(defn- bindKeys\\r\\n  [component]\\r\\n  (let\\r\\n    [escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)\\n     f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)]\\n    (-> component .getRootPane (.registerKeyboardAction \\n                                 (fn [event]\\n                                   (println \\"fdsfjds\\"))\\n                                 escKey\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use\\n    [seesaw\\n     [core]\\n     [font]]\\n    [inspector-jay\\n     [tree-node \:only [object-node]]\\n     [tree-model]\\n     [tree-ui]])\\n  (\:import\\n    [javax.swing KeyStroke JFrame JComponent]\\n    [java.awt.event KeyEvent]))" "(defn- bindKeys\\r\\n  [component]\\r\\n  (let\\r\\n    [escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)\\n     f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)]\\n    (-> component .getRootPane (.registerKeyboardAction \\n                                 (fn [event]\\n                                   (println \\"fdsfjds\\"))\\n                                 escKey\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))" "(inspect 5)" "(defn- bindKeys\\r\\n  [component]\\r\\n  (let\\r\\n    [escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)\\n     f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)]\\n    (-> component .getRootPane (.registerKeyboardAction\\n                                 (proxy [ActionListener] []\\n                                   (actionPerformed [event]\\n                                     (println \\"fdsfjds\\"))\\n                                 escKey\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))" "(defn- bindKeys\\r\\n  [component]\\r\\n  (let\\r\\n    [escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)\\n     f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)]\\n    (-> component .getRootPane (.registerKeyboardAction\\n                                 (proxy [ActionListener] []\\n                                   (actionPerformed [event]\\n                                     (println \\"fdsfjds\\")))\\n                                 escKey\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you examine the fields and methods of Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use\\n    [seesaw\\n     [core]\\n     [font]]\\n    [inspector-jay\\n     [tree-node \:only [object-node]]\\n     [tree-model]\\n     [tree-ui]])\\n  (\:import\\n    [javax.swing KeyStroke JFrame JComponent]\\n    [java.awt.event KeyEvent ActionListener]))" "(defn- bindKeys\\r\\n  [component]\\r\\n  (let\\r\\n    [escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)\\n     f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)]\\n    (-> component .getRootPane (.registerKeyboardAction\\n                                 (proxy [ActionListener] []\\n                                   (actionPerformed [event]\\n                                     (println \\"fdsfjds\\")))\\n                                 escKey\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))" "(inspect 5)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn bindKeys\\r\\n  [component]\\r\\n  (let\\r\\n    [escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)\\r\\n     f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)]\\r\\n    (-> component .getRootPane (.registerKeyboardAction\\r\\n                                 (proxy [ActionListener] []\\r\\n                                   (actionPerformed [event]\\r\\n                                     (println \\"fdsfjds\\")))\\r\\n                                 escKey\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn bindKeys\\r\\n  [frame]\\r\\n  (let\\r\\n    [escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)\\r\\n     f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)]\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\n                             (proxy [ActionListener] []\\n                               (actionPerformed [event]\\n                                 (-> frame .dispose)))\\r\\n                                 escKey\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))\\n(clojure.core/ns inspector-jay.core)" "(inspect 5)" "(clojure.core/ns inspector-jay.tree-ui)\\n(ns inspector-jay.tree-ui\\n  \\"Defines how each tree node is displayed in the GUI\\"\\n  {\:author \\"Tim Molderez\\"}\\n  (\:use \\n    [clojure.string \:only [join]]\\n    [clojure.java.io \:only [resource]]\\n    [seesaw.core]\\n    [inspector-jay.tree-node])\\r\\n  (\:import\\n     [javax.swing JTextArea KeyStroke JFrame JTree JComponent]\\r\\n     [javax.swing.tree DefaultTreeCellRenderer]\\r\\n     [javax.swing.event TreeSelectionListener]\\n     [java.awt.event KeyEvent ActionListener]\\r\\n     [java.lang.reflect Modifier]))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-ui)\\n(ns inspector-jay.tree-ui\\n  \\"Defines how each tree node is displayed in the GUI\\"\\n  {\:author \\"Tim Molderez\\"}\\n  (\:use \\n    [clojure.string \:only [join]]\\n    [clojure.java.io \:only [resource]]\\n    [clojure.java.javadoc]\\n    [seesaw.core]\\n    [inspector-jay.tree-node])\\r\\n  (\:import\\n     [javax.swing JTextArea KeyStroke JFrame JTree JComponent]\\r\\n     [javax.swing.tree DefaultTreeCellRenderer]\\r\\n     [javax.swing.event TreeSelectionListener]\\n     [java.awt.event KeyEvent ActionListener]\\r\\n     [java.lang.reflect Modifier]))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn bindKeys\\r\\n  [^JFrame frame ^JTree tree]\\n  \\"Attach various key bindings to frame, given tree\\"\\r\\n  (let\\r\\n    [f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)\\n     escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\n    ; Search javadoc for the currently selected node and open it in a browser window\\n    (-> frame .getRootPane (.registerKeyboardAction\\r\\n                             (proxy [ActionListener] []\\r\\n                               (actionPerformed [event]\\r\\n                                 (javadoc (-> (-> tree .getLastSelectedPathComponent) .getValueClass)))\\r\\n                                 f1Key\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))\\n    ; Close the window\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\n                             (proxy [ActionListener] []\\n                               (actionPerformed [event]\\n                                 (-> frame .dispose)))\\r\\n                                 escKey\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))\\n(clojure.core/ns inspector-jay.core)" "(defn bindKeys\\r\\n  [^JFrame frame ^JTree tree]\\n  \\"Attach various key bindings to frame, given tree\\"\\r\\n  (let\\r\\n    [f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)\\n     escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\n    ; Search javadoc for the currently selected node and open it in a browser window\\n    (-> frame .getRootPane (.registerKeyboardAction\\r\\n                             (proxy [ActionListener] []\\r\\n                               (actionPerformed [event]\\r\\n                                 (javadoc (-> (-> tree .getLastSelectedPathComponent) .getValueClass)))\\r\\n                                 f1Key\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW)))\\n    ; Close the window\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\n                             (proxy [ActionListener] []\\n                               (actionPerformed [event]\\n                                 (-> frame .dispose)))\\r\\n                                 escKey\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))" "(defn bindKeys\\r\\n  [^JFrame frame ^JTree tree]\\n  \\"Attach various key bindings to frame, given tree\\"\\r\\n  (let\\r\\n    [f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)\\n     escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\n    ; Search javadoc for the currently selected node and open it in a browser window\\n    (-> frame .getRootPane (.registerKeyboardAction\\r\\n                             (proxy [ActionListener] []\\r\\n                               (actionPerformed [event]\\r\\n                                 5 ;(javadoc (-> (-> tree .getLastSelectedPathComponent) .getValueClass)))\\r\\n                                 f1Key\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW)))\\n    ; Close the window\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\n                             (proxy [ActionListener] []\\n                               (actionPerformed [event]\\n                                 (-> frame .dispose)))\\r\\n                                 escKey\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))" "(defn bindKeys\\r\\n  [^JFrame frame ^JTree tree]\\n  \\"Attach various key bindings to frame, given tree\\"\\r\\n  (let\\r\\n    [f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)\\n     escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\n    ; Search javadoc for the currently selected node and open it in a browser window\\n    (-> frame .getRootPane (.registerKeyboardAction\\r\\n                             (proxy [ActionListener] []\\r\\n                               (actionPerformed [event]\\r\\n                                 5) ;(javadoc (-> (-> tree .getLastSelectedPathComponent) .getValueClass)))\\r\\n                                 f1Key\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW)))\\n    ; Close the window\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\n                             (proxy [ActionListener] []\\n                               (actionPerformed [event]\\n                                 (-> frame .dispose)))\\r\\n                                 escKey\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))" "(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel]  \\n  \\"Returns a listener that displays detailed information when a tree node is clicked\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent))))))" "(defn bindKeys\\r\\n  [^JFrame frame ^JTree tree]\\n  \\"Attach various key bindings to frame, given tree\\"\\r\\n  (let\\r\\n    [f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)\\n     escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\n    ; Search javadoc for the currently selected node and open it in a browser window\\n    (-> frame .getRootPane (.registerKeyboardAction\\r\\n                             (proxy [ActionListener] []\\r\\n                               (actionPerformed [event]\\r\\n                                 (javadoc (-> (-> tree .getLastSelectedPathComponent) .getValueClass)))\\r\\n                                 f1Key\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW)))\\n    ; Close the window\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\n                             (proxy [ActionListener] []\\n                               (actionPerformed [event]\\n                                 (-> frame .dispose)))\\r\\n                                 escKey\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))" "(defn bindKeys\\r\\n  [^JFrame frame ^JTree tree]\\n  \\"Attach various key bindings to frame, given tree\\"\\r\\n  (let\\r\\n    [f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)\\n     escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\n    ; Search javadoc for the currently selected node and open it in a browser window\\n\\n    ; Close the window\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\n                             (proxy [ActionListener] []\\n                               (actionPerformed [event]\\n                                 (-> frame .dispose)))\\r\\n                                 escKey\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))" "(defn bindKeys\\r\\n  [^JFrame frame ^JTree tree]\\n  \\"Attach various key bindings to frame, given tree\\"\\r\\n  (let\\r\\n    [f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)\\n     escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\n    ; Search javadoc for the currently selected node and open it in a browser window\\n    (-> frame .getRootPane (.registerKeyboardAction\\r\\n                             (proxy [ActionListener] []\\r\\n                               (actionPerformed [event]\\r\\n                                 (javadoc (-> (-> tree .getLastSelectedPathComponent) .getValueClass)))\\r\\n                                 f1Key\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW)))\\n    ; Close the window\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\n                             (proxy [ActionListener] []\\n                               (actionPerformed [event]\\n                                 (-> frame .dispose)))\\r\\n                                 escKey\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))" "(defn bindKeys\\r\\n  [^JFrame frame ^JTree tree]\\n  \\"Attach various key bindings to frame, given tree\\"\\r\\n  (let\\r\\n    [f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)\\n     escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\n    ; Search javadoc for the currently selected node and open it in a browser window\\n    (-> frame .getRootPane (.registerKeyboardAction\\r\\n                             (proxy [ActionListener] []\\r\\n                               (actionPerformed [event]\\r\\n                                 (println \\"weqw\\")\\r\\n                                 f1Key\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW)))\\n    ; Close the window\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\n                             (proxy [ActionListener] []\\n                               (actionPerformed [event]\\n                                 (-> frame .dispose)))\\r\\n                                 escKey\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))" "(defn bindKeys\\r\\n  [^JFrame frame ^JTree tree]\\n  \\"Attach various key bindings to frame, given tree\\"\\r\\n  (let\\r\\n    [f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)\\n     escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\n    ; Search javadoc for the currently selected node and open it in a browser window\\n    (-> frame .getRootPane (.registerKeyboardAction\\r\\n                             (proxy [ActionListener] []\\r\\n                               (actionPerformed [event]\\r\\n                                 (println \\"weqw\\"))\\r\\n                                 f1Key\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW)))\\n    ; Close the window\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\n                             (proxy [ActionListener] []\\n                               (actionPerformed [event]\\n                                 (-> frame .dispose)))\\r\\n                                 escKey\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))" "(defn bindKeys\\r\\n  [^JFrame frame ^JTree tree]\\n  \\"Attach various key bindings to frame, given tree\\"\\r\\n  (let\\r\\n    [f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)\\n     escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\n    ; Search javadoc for the currently selected node and open it in a browser window\\n    ; Close the window\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\n                             (proxy [ActionListener] []\\n                               (actionPerformed [event]\\n                                 (-> frame .dispose)))\\r\\n                                 escKey\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))" "(defn bindKeys\\r\\n  [^JFrame frame ^JTree tree]\\n  \\"Attach various key bindings to frame, given tree\\"\\r\\n  (let\\r\\n    [f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)\\n     escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\n    ; Search javadoc for the currently selected node and open it in a browser window\\n    ; Close the window\\n    (-> frame .getRootPane (.registerKeyboardAction\\r\\n                             (proxy [ActionListener] []\\r\\n                               (actionPerformed [event]\\r\\n                                 (-> frame .dispose)))\\r\\n                                 escKey\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\n                             (proxy [ActionListener] []\\n                               (actionPerformed [event]\\n                                 (-> frame .dispose)))\\r\\n                                 escKey\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))" "(defn bindKeys\\r\\n  [^JFrame frame ^JTree tree]\\r\\n  \\"Attach various key bindings to frame, given tree\\"\\r\\n  (let\\r\\n    [f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)\\r\\n     escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\r\\n    ; Search javadoc for the currently selected node and open it in a browser window\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\r\\n                             (proxy [ActionListener] []\\r\\n                               (actionPerformed [event]\\r\\n                                 (javadoc (-> (-> tree .getLastSelectedPathComponent) .getValueClass))))\\r\\n                                 f1Key\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))\\r\\n    ; Close the window\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\r\\n                             (proxy [ActionListener] []\\r\\n                               (actionPerformed [event]\\r\\n                                 (-> frame .dispose)))\\r\\n                                 escKey\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))" "(inspect 5)" ";; Switching to inspector-jay.core namespace" "(inspect 5)" "(inspect (new JFrame))" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod is-leaf \:default [^TreeNode node]\\n  (not (-> node .hasValue)))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-model)\\n(defmethod is-leaf \:default [^ITreeNode node]\\n  (not (-> node .hasValue)))\\n(clojure.core/ns inspector-jay.core)" "(use clojure.core.typed)" "(use clojure.repl)" "(use '(clojure.repl))" "(use '(clojure.core.typed))" "(ann 5)" "ann" "(def bla \\"hello\\")" "(ann bla String)" "(use '(clojure.core.typed))" "(clojure.core.typed.ann bla String)" "(use '(clojure.repl))" "(doc doc)" "(clojure.core.typed/ann bla String)" "(core.typed/ann bla String)" "(use '(core.typed))" "(core.typed/ann bla String)" ";; Switching to inspector-jay.core namespace" "(inspect 5)" "(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\n  The return value of inspect is the object itself, so you can plug in this function anywhere you like.\\"\\r\\n\\t(let [f (frame \:title (str \\"Object inspector \: \\" (.toString object)) \\n                \:minimum-size [(options \:width) \:by (options \:height)]\\n                \:on-close \:dispose)\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object)) \\n       crumbs (label \\"hello\\")\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)\\n       border-panel (border-panel \:south crumbs \:center split-pane)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (bindKeys f obj-tree)\\n   (config\! f \:content border-panel)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))" "(inspect 5)" "(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\n  The return value of inspect is the object itself, so you can plug in this function anywhere you like.\\"\\r\\n\\t(let [f (frame \:title (str \\"Object inspector \: \\" (.toString object)) \\n                \:minimum-size [(options \:width) \:by (options \:height)]\\n                \:on-close \:dispose)\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object)) \\n       crumbs (label \:text \\"hello\\" \:icon (icon (resource \\"icons/methpub_obj.gif\\")))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)\\n       border-panel (border-panel \:south crumbs \:center split-pane)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (bindKeys f obj-tree)\\n   (config\! f \:content border-panel)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you inspect Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class)\\n  (\:use\\n    [clojure.java.io \:only [resource]]\\n    [seesaw\\n     [core]\\n     [font]]\\n    [inspector-jay\\n     [tree-node \:only [object-node]]\\n     [tree-model]\\n     [tree-ui]]))" "(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\n  The return value of inspect is the object itself, so you can plug in this function anywhere you like.\\"\\r\\n\\t(let [f (frame \:title (str \\"Object inspector \: \\" (.toString object)) \\n                \:minimum-size [(options \:width) \:by (options \:height)]\\n                \:on-close \:dispose)\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object)) \\n       crumbs (label \:text \\"hello\\" \:icon (icon (resource \\"icons/methpub_obj.gif\\")))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)\\n       border-panel (border-panel \:south crumbs \:center split-pane)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (bindKeys f obj-tree)\\n   (config\! f \:content border-panel)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))" "(inspect 5)" "(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\n  The return value of inspect is the object itself, so you can plug in this function anywhere you like.\\"\\r\\n\\t(let [f (frame \:title (str \\"Object inspector \: \\" (.toString object)) \\n                \:minimum-size [(options \:width) \:by (options \:height)]\\n                \:on-close \:dispose)\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object)) \\n       crumbs (label \:text \\"hello\\" \:icon (icon (resource \\"icons/toggle_breadcrumbd.gif\\")))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)\\n       border-panel (border-panel \:south crumbs \:center split-pane)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (bindKeys f obj-tree)\\n   (config\! f \:content border-panel)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))" "(inspect 5)" "(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\n  The return value of inspect is the object itself, so you can plug in this function anywhere you like.\\"\\r\\n\\t(let [f (frame \:title (str \\"Object inspector \: \\" (.toString object)) \\n                \:minimum-size [(options \:width) \:by (options \:height)]\\n                \:on-close \:dispose)\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object)) \\n       crumbs (label \:text \\"hello\\" \:icon (icon (resource \\"icons/toggle_breadcrumb.gif\\")))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)\\n       border-panel (border-panel \:south crumbs \:center split-pane)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (bindKeys f obj-tree)\\n   (config\! f \:content border-panel)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))" "(inspect 5)" "(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\n  The return value of inspect is the object itself, so you can plug in this function anywhere you like.\\"\\r\\n\\t(let [f (frame \:title (str \\"Object inspector \: \\" (.toString object)) \\n                \:minimum-size [(options \:width) \:by (options \:height)]\\n                \:on-close \:dispose)\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object)) \\n       crumbs (label \:text (to-string (object-node object)) \:icon (icon (resource \\"icons/toggle_breadcrumb.gif\\")))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)\\n       border-panel (border-panel \:south crumbs \:center split-pane)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info)))\\n   (bindKeys f obj-tree)\\n   (config\! f \:content border-panel)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))" "(inspect 5)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text (interpose \\" > \\" (-> event .getPath))))))\\n(clojure.core/ns inspector-jay.core)" "(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\n  The return value of inspect is the object itself, so you can plug in this function anywhere you like.\\"\\r\\n\\t(let [f (frame \:title (str \\"Object inspector \: \\" (.toString object)) \\n                \:minimum-size [(options \:width) \:by (options \:height)]\\n                \:on-close \:dispose)\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object)) \\n       crumbs (label \:text (to-string (object-node object)) \:icon (icon (resource \\"icons/toggle_breadcrumb.gif\\")))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)\\n       border-panel (border-panel \:south crumbs \:center split-pane)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info crumbs)))\\n   (bindKeys f obj-tree)\\n   (config\! f \:content border-panel)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))" "(inspect 5)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text (interpose \\" > \\" (-> event .getNewLeadSelectionPath .getPath))))))\\n(clojure.core/ns inspector-jay.core)" "(inspect 5)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text (interpose \\" > \\" (map to-string (-> event .getNewLeadSelectionPath .getPath))))))\\n(clojure.core/ns inspector-jay.core)" "(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text (interpose \\" > \\" (map to-string (-> event .getNewLeadSelectionPath .getPath)))))))" "(inspect 5)" ";; Switching to inspector-jay.core namespace" "(inspect 5)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text (join(interpose \\" > \\" (map to-string (-> event .getNewLeadSelectionPath .getPath))))))))\\n(clojure.core/ns inspector-jay.core)" "(inspect 5)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmulti to-string-breadcrumb\\r\\n  \\"Retrieve a string to describe a tree node in a path of breadcrumbs\\"\\r\\n  (fn [node] (-> node .getKind)))\\n(clojure.core/ns inspector-jay.core)" "(inspect 5)" ";; Switching to inspector-jay.core namespace" "(inspect (new Object))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string-breadcrumb \:method [node]\\r\\n  (str\\r\\n    (-> node .getMethod .getName)\\r\\n    \\"(\\"\\r\\n    (join (interpose \\", \\" (map (memfn getSimpleName) (-> node .getMethod .getParameterTypes))))\\r\\n    \\")\\"))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new Object))" "(count \\"dsfsd\\")" "(take 3 \\"dsfls\\")" "(str (take 3 \\"dsfls\\"))" "\\"sasda\\"" "(type \\"fsd\\")" "(apply str (take 3 \\"dsfls\\"))" "(-> \\"fdsjif\\" (.substring 0 length))" "(-> \\"fdsjif\\" (.substring 0 2))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn truncate [string length]\\n  (if (> (count string) length)\\n    (-> string (.substring 0 length))\\n    string))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn truncate [string length]\\n  (if (> (count string) length)\\n    (str (-> string (.substring 0 length)) \\"...\\")\\n    string))\\n(clojure.core/ns inspector-jay.core)" "(truncate \\"dfksdjfsfsd;lfjkdslfs;d\\" 5)" ";; Switching to inspector-jay.tree-ui namespace" "(truncate \\"dfksdjfsfsd;lfjkdslfs;d\\" 5)" "(truncate \\"dfksdjfsfsd;lfjkdslfs;d\\" 35)" "(defn truncate [string length]\\n  \\"Returns a truncated string. If the string is longer than length, we only return the first 'length' characters and append an ellipsis to it.\\"\\r\\n  (if (> (count string) length)\\r\\n    (str (-> string (.substring 0 length)) \\"...\\")\\r\\n    string))" "(defmethod to-string-breadcrumb \:method [node]\\r\\n  (truncate (str\\r\\n    (-> node .getMethod .getName)\\r\\n    \\"(\\"\\r\\n    (join (interpose \\", \\" (map (memfn getSimpleName) (-> node .getMethod .getParameterTypes))))\\r\\n    \\")\\") crumb-length))" "(def crumb-length 10)" "(defmethod to-string-breadcrumb \:method [node]\\r\\n  (truncate (str\\r\\n    (-> node .getMethod .getName)\\r\\n    \\"(\\"\\r\\n    (join (interpose \\", \\" (map (memfn getSimpleName) (-> node .getMethod .getParameterTypes))))\\r\\n    \\")\\") crumb-length))" "(defmethod to-string-breadcrumb \:field [node]\\r\\n  (truncate (str (-> node .getField .getName)) crumb-length)\\n\\n(defmethod to-string-verbose \:default [node]\\r\\n  (str\\r\\n    (-> node .getValue .getClass)\\r\\n    \\"\\\\n\\\\n\\"\\r\\n    (-> node .getValue)))" "(defmethod to-string-breadcrumb \:field [node]\\r\\n  (truncate (str (-> node .getField .getName)) \\n    crumb-length))" "(inspect 5)" ";; Switching to inspector-jay.core namespace" "(inspect 5)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string-breadcrumb \:default [node]\\r\\n  (truncate (-> node .getValue .toString) crumb-length))\\n(clojure.core/ns inspector-jay.core)" "(inspect 5)" "(clojure.core/ns inspector-jay.tree-ui)\\n(def crumb-length 15)\\n(clojure.core/ns inspector-jay.core)" "(inspect 5)" "(inspect (new JFrame))" "(import javax.swing.JFrame)" "(inspect (new JFrame))" "(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\n  The return value of inspect is the object itself, so you can plug in this function anywhere you like.\\"\\r\\n\\t(let [f (frame \:title (str \\"Object inspector \: \\" (.toString object)) \\n                \:minimum-size [(options \:width) \:by (options \:height)]\\n                \:on-close \:dispose)\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (options \:font))\\n       obj-tree (tree \:model (tree-model object)) \\n       crumbs (label \:text (to-string-breadcrumb (object-node object)) \:icon (icon (resource \\"icons/toggle_breadcrumb.gif\\")))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)\\n       border-panel (border-panel \:south crumbs \:center split-pane)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info crumbs)))\\n   (bindKeys f obj-tree)\\n   (config\! f \:content border-panel)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))" "(inspect (new JFrame))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string-breadcrumb \:default [node]\\r\\n  (truncate \\n    (-> node .getValueClass .toString)\\n    crumb-length))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-ui)\\n(def crumb-length 20)\\n(clojure.core/ns inspector-jay.core)" "(inspect (new JFrame))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string-breadcrumb \:default [node]\\r\\n  (truncate \\n    (-> node .getValueClass .getSimpleName)\\n    crumb-length))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new JFrame))" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn truncate [string length]\\r\\n  \\"Returns a truncated string. If the string is longer than length, we only return the first 'length' characters and append an ellipsis to it.\\"\\r\\n  (if (> (count string) length)\\r\\n    (str (subs string 0 length) \\"...\\")\\r\\n    string))\\n(clojure.core/ns inspector-jay.core)" "(inspect (new JFrame))" "(defn\\n  -inspect [object]\\n  \\"Java wrapper for the inspect function.\\"\\n  (inspect object))" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you inspect Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class\\n    \:name InspectorJay\\n    \:prefix java-)\\n    \:methods [[inspect [Object] Object]]\\n  (\:use\\n    [clojure.java.io \:only [resource]]\\n    [seesaw\\n     [core]\\n     [font]]\\n    [inspector-jay\\n     [tree-node \:only [object-node]]\\n     [tree-model]\\n     [tree-ui]]))" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you inspect Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class\\n    \:name InspectorJay\\n    \:prefix java-\\n    \:methods [[inspect [Object] Object]])\\n  (\:use\\n    [clojure.java.io \:only [resource]]\\n    [seesaw\\n     [core]\\n     [font]]\\n    [inspector-jay\\n     [tree-node \:only [object-node]]\\n     [tree-model]\\n     [tree-ui]]))" "(ns inspector-jay.core\\n  \\"Inspector Jay is a simple GUI application that lets you inspect Java objects and Clojure data structures.\\"\\n  {\:author \\"Tim Molderez\\"}\\r\\n  (\:gen-class\\n    \:name InspectorJay\\n    \:prefix java-\\n    \:methods [[\#^{\:static true} inspect [Object] Object]])\\n  (\:use\\n    [clojure.java.io \:only [resource]]\\n    [seesaw\\n     [core]\\n     [font]]\\n    [inspector-jay\\n     [tree-node \:only [object-node]]\\n     [tree-model]\\n     [tree-ui]]))" ";; Switching to inspector-jay.core namespace" "(clojure.core/ns inspector-jay.tree-ui)\\n(defmethod to-string-breadcrumb \:default [node]\\r\\n  (truncate \\n    (-> node .getValue .toString)\\n    crumb-length))\\n(clojure.core/ns user)" ";; Switching to inspector-jay.core namespace" "(inspect 5)" "(inspect (+ 5 5))" "(inspect (new Object))" ";; Switching to inspector-jay.core namespace" "(inspect (new Object))" ";; Switching to inspector-jay.core namespace" "(inspect (new String))" "(inspect [1 2 3])" "(inspect {\:a \\"sdfds\\" \:b \\"FSDFS\\"})" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn bindKeys\\r\\n  [^JFrame frame ^JTree tree]\\r\\n  \\"Attach various key bindings to frame, given tree\\"\\r\\n  (let\\r\\n    [f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)\\r\\n     escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\r\\n    ; Search javadoc for the currently selected node and open it in a browser window\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\r\\n                             (proxy [ActionListener] []\\r\\n                               (actionPerformed [event]\\r\\n                                 (javadoc (-> (-> tree .getLastSelectedPathComponent) .getValueClass))))\\r\\n                                 f1Key\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))\\r\\n    ; Close the window\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\r\\n                             (proxy [ActionListener] []\\r\\n                               (actionPerformed [event]\\r\\n                                 (-> frame .dispose)))\\r\\n                                 escKey\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text \\n        (str(\\"<html>\\"\\n              (join(interpose \\"<font color\=\\\\\\"blue\\\\\\"> &gt; </font>\\" \\n                     (map to-string-breadcrumb (-> event .getNewLeadSelectionPath .getPath))))\\n              \\"</html>\\"))))))\\n(clojure.core/ns inspector-jay.core)" "(inspect {\:a \\"sdfds\\" \:b \\"FSDFS\\"})" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text \\n        (str(\\"<html>\\"\\n              (join(interpose \\"<font color\=\\\\\\"blue\\\\\\"> - </font>\\" \\n                     (map to-string-breadcrumb (-> event .getNewLeadSelectionPath .getPath))))\\n              \\"</html>\\"))))))\\n(clojure.core/ns inspector-jay.core)" "(inspect {\:a \\"sdfds\\" \:b \\"FSDFS\\"})" "(inspect [1 2 3])" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text \\n        (str(\\n              (join(interpose \\"<font color\=\\\\\\"blue\\\\\\"> - </font>\\" \\n                     (map to-string-breadcrumb (-> event .getNewLeadSelectionPath .getPath))))\\n              ))))))\\n(clojure.core/ns inspector-jay.core)" "(inspect [1 2 3])" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text \\n        (str\\n              (join(interpose \\"<font color\=\\\\\\"blue\\\\\\"> - </font>\\" \\n                     (map to-string-breadcrumb (-> event .getNewLeadSelectionPath .getPath))))\\n              )))))\\n(clojure.core/ns inspector-jay.core)" "(inspect [1 2 3])" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text \\n        (str\\n          \\"<html>\\"\\n          (join(interpose \\"<font color\=\\\\\\"blue\\\\\\"> - </font>\\" \\n                 (map to-string-breadcrumb (-> event .getNewLeadSelectionPath .getPath))))\\n          \\"</html>\\"\\n              \\n              )))))\\n(clojure.core/ns inspector-jay.core)" "(inspect [1 2 3])" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text \\n        (str\\n          \\"<html>\\"\\n          (join(interpose \\"<font color\=\\\\\\"blue\\\\\\"> &gt; </font>\\" \\n                 (map to-string-breadcrumb (-> event .getNewLeadSelectionPath .getPath))))\\n          \\"</html>\\"\\n              \\n              )))))\\n(clojure.core/ns inspector-jay.core)" "(inspect [1 2 3])" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text \\n        (str\\n          \\"<html>\\"\\n          (join(interpose \\"<font color\=\\\\\\"red\\\\\\"> &gt; </font>\\" \\n                 (map to-string-breadcrumb (-> event .getNewLeadSelectionPath .getPath))))\\n          \\"</html>\\"\\n              \\n              )))))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text \\n        (str\\n          \\"<html>\\"\\n          (join(interpose \\"<font color\=\\\\\\"red\\\\\\"> &gt; </font>\\" \\n                 (map to-string-breadcrumb (-> event .getNewLeadSelectionPath .getPath))))\\n          \\"</html>\\")))))\\n(clojure.core/ns inspector-jay.core)" "(inspect [1 2 3])" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text \\n        (str\\n          \\"<html>\\"\\n          (join(interpose \\"<b> &gt; </b>\\" \\n                 (map to-string-breadcrumb (-> event .getNewLeadSelectionPath .getPath))))\\n          \\"</html>\\")))))\\n(clojure.core/ns inspector-jay.core)" "(inspect [1 2 3])" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text \\n        (str\\n          \\"<html>\\"\\n          (join(interpose \\"<b>  &gt;  </b>\\" \\n                 (map to-string-breadcrumb (-> event .getNewLeadSelectionPath .getPath))))\\n          \\"</html>\\")))))\\n(clojure.core/ns inspector-jay.core)" "(inspect [1 2 3])" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text \\n        (str\\n          \\"<html>\\"\\n          (join(interpose \\"<font color\=/\\"\#268bd2/\\"><b>  &gt;  </b></font>\\" \\n                 (map to-string-breadcrumb (-> event .getNewLeadSelectionPath .getPath))))\\n          \\"</html>\\")))))\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text \\n        (str\\n          \\"<html>\\"\\n          (join(interpose \\"<font color\=\\\\\\"\#268bd2\\\\\\"><b>  &gt;  </b></font>\\" \\n                 (map to-string-breadcrumb (-> event .getNewLeadSelectionPath .getPath))))\\n          \\"</html>\\")))))\\n(clojure.core/ns inspector-jay.core)" "(inspect [1 2 3])" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text \\n        (str\\n          \\"<html>\\"\\n          (join(interpose \\"<font color\=\\\\\\"\#859900\\\\\\"><b>  &gt;  </b></font>\\" \\n                 (map to-string-breadcrumb (-> event .getNewLeadSelectionPath .getPath))))\\n          \\"</html>\\")))))\\n(clojure.core/ns inspector-jay.core)" "(inspect [1 2 3])" "(clojure.core/ns inspector-jay.tree-ui)\\n268bd2\\n(clojure.core/ns inspector-jay.core)" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn bindKeys\\r\\n  [^JFrame frame ^JTree tree]\\r\\n  \\"Attach various key bindings to frame, given tree\\"\\r\\n  (let\\r\\n    [f1Key (KeyStroke/getKeyStroke KeyEvent/VK_F1 0)\\r\\n     escKey (KeyStroke/getKeyStroke KeyEvent/VK_ESCAPE 0)]\\r\\n    ; Search javadoc for the currently selected node and open it in a browser window\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\r\\n                             (proxy [ActionListener] []\\r\\n                               (actionPerformed [event]\\r\\n                                 (javadoc (-> (-> tree .getLastSelectedPathComponent) .getValueClass))))\\r\\n                                 f1Key\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))\\r\\n    ; Close the window\\r\\n    (-> frame .getRootPane (.registerKeyboardAction\\r\\n                             (proxy [ActionListener] []\\r\\n                               (actionPerformed [event]\\r\\n                                 (-> frame .dispose)))\\r\\n                                 escKey\\r\\n                                 JComponent/WHEN_IN_FOCUSED_WINDOW))))\\n(clojure.core/ns inspector-jay.core)" "(inspect [1 2 3])" "(clojure.core/ns inspector-jay.tree-ui)\\n(defn tree-listener ^TreeSelectionListener\\n  [^JTextArea info-panel crumbs-panel]  \\n  \\"Update the detailed information panel, as well as the breadcrumbs, whenever a tree node is selected\\"\\r\\n  (proxy [TreeSelectionListener] []\\r\\n    (valueChanged [event]\\n      (config\! info-panel \:text (to-string-verbose (-> event .getNewLeadSelectionPath .getLastPathComponent)))\\n      (config\! crumbs-panel \:text \\n        (str\\n          \\"<html>\\"\\n          (join(interpose \\"<font color\=\\\\\\"\#268bd2\\\\\\"><b>  &gt;  </b></font>\\" \\n                 (map to-string-breadcrumb (-> event .getNewLeadSelectionPath .getPath))))\\n          \\"</html>\\")))))\\n(clojure.core/ns inspector-jay.core)" "(inspect [1 2 3])" "(defn \\r\\n\\tinspect ^Object\\r\\n\\t[^Object object]\\n \\"Displays an object inspector window for a given object.\\n  The return value of inspect is the object itself, so you can plug in this function anywhere you like.\\"\\r\\n\\t(let [f (frame \:title (str \\"Object inspector \: \\" (.toString object)) \\n                \:minimum-size [(gui-options \:width) \:by (gui-options \:height)]\\n                \:on-close \:dispose)\\n       obj-info (text \:multi-line? true \:editable? false \:text (to-string-verbose (object-node object)) \\n                  \:font (gui-options \:font))\\n       obj-tree (tree \:model (tree-model object)) \\n       crumbs (label \:text (to-string-breadcrumb (object-node object)) \:icon (icon (resource \\"icons/toggle_breadcrumb.gif\\")))\\n       split-pane (top-bottom-split (scrollable obj-info) (scrollable obj-tree) \:divider-location 1/3)\\n       border-panel (border-panel \:south crumbs \:center split-pane)]\\n   (-> obj-tree (.setCellRenderer (tree-renderer)))\\n   (-> obj-tree (.addTreeSelectionListener (tree-listener obj-info crumbs)))\\n   (bindKeys f obj-tree)\\n   (config\! f \:content border-panel)\\n   (-> f pack\! show\!)\\n   (-> obj-tree .requestFocus)\\n   object))" ";; Switching to inspector-jay.core namespace" "(inspect [1 2 3])" ";; Switching to inspector-jay.core namespace" "1" "(inspect (new Object))" ";; Switching to inspector-jay.core namespace" "(inspect (new Object))" "(inspect {\:a dsjkflds \:b \\"dsfmksd\\"})" "(inspect {\:a 13432 \:b \\"dsfmksd\\"})" "(inspect \\"fdsf\\")"]
eclipse.preferences.version=1
